# Story 3.3: Status Polling and Monitoring

---

## Status

**Approved**

---

## Story

**As a** web application user,
**I want** to see real-time pipeline execution progress in the browser,
**so that** I know which stage is currently running and when the pipeline completes.

---

## Acceptance Criteria

1. Pipeline viewer page `/pipeline/[runId]` is a client component that polls `/api/status/[runId]` every 5 seconds
2. On mount, page immediately fetches initial status and continues polling until status is "complete" or "error"
3. Display vertical column of 5 stage boxes flowing downward showing stage number, short name, and status icon (✓ complete, ⏳ running, ⌛ pending)
4. Active stage (current_stage) is highlighted with border and pulse animation
5. Completed stages (< current_stage) show green checkmark, pending stages (> current_stage) are grayed out
6. When `current_stage >= 1` and `stage1_data` exists, display 2 track cards side-by-side matching `docs/image/track-division.png` design
7. Track cards show title, summary, and "Selected" badge with checkmark
8. Display current stage detail panel below stage boxes with stage description and status message
9. When `status === "complete"`, show "View Opportunities →" button that redirects to `/results/[runId]`
10. Polling cleanup: Clear setTimeout on component unmount to prevent memory leaks
11. Error handling: Display "Pipeline not found" for 404, "Pipeline failed" for error status, network retry once then show error
12. Loading states: Show skeleton loaders for tracks while Stage 1 is running

---

## Tasks / Subtasks

- [ ] **Task 1: Create pipeline viewer page** (AC: 1, 2)
  - [ ] Create `app/pipeline/[runId]/page.tsx` file
  - [ ] Add `'use client'` directive at top
  - [ ] Import hooks: `useEffect`, `useState`, `useParams`, `useRouter`
  - [ ] Extract `runId` from URL params
  - [ ] Create state: `status`, `currentStage`, `stage1Data`, `loading`
  - [ ] Implement `pollStatus()` async function
  - [ ] Call `/api/status/${runId}` with fetch
  - [ ] Update state with response data
  - [ ] Schedule next poll with `setTimeout(pollStatus, 5000)` if status is "running"
  - [ ] Call `pollStatus()` on mount in `useEffect`
  - [ ] Return cleanup function: `() => clearTimeout(timeoutId)`

- [ ] **Task 2: Create vertical stage boxes** (AC: 3, 4, 5)
  - [ ] Create `components/pipeline/StageBox.tsx` component
  - [ ] Accept props: `stageNumber`, `stageName`, `status` ("completed" | "running" | "pending")
  - [ ] Render stage number and short name
  - [ ] Display status icon: ✓ (completed), ⏳ (running), ⌛ (pending)
  - [ ] Apply conditional styling:
    - Completed: `bg-green-500`
    - Running: `bg-blue-500 animate-pulse border-2 border-blue-700`
    - Pending: `bg-gray-300 opacity-50`
  - [ ] In main page, map 5 stages to `<StageBox>` components
  - [ ] Use Flexbox (flex-col) for vertical layout with downward arrow connectors

- [ ] **Task 3: Create Stage 1 track cards** (AC: 6, 7, 12)
  - [ ] Create `components/pipeline/TrackCard.tsx` component
  - [ ] Accept props: `trackNumber`, `title`, `summary`
  - [ ] Use shadcn/ui `<Card>` component
  - [ ] Display track title with "Track {number}:" prefix
  - [ ] Display track summary (2-3 sentences)
  - [ ] Add `<Badge variant="success">✓ Selected</Badge>` in top-right corner
  - [ ] In main page, conditionally render 2 tracks when `stage1Data` exists
  - [ ] Show `<Skeleton>` components while `stage1Data` is null and `currentStage === 1`
  - [ ] Use Grid layout for side-by-side display

- [ ] **Task 4: Create current stage detail panel** (AC: 8, 9)
  - [ ] Create `components/pipeline/DetailPanel.tsx` component
  - [ ] Accept props: `currentStage`, `status`, `runId`
  - [ ] Define stage descriptions:
    - Stage 1: "Track Division - Selected 2 inspiration tracks"
    - Stage 2: "Signal Amplification - Extracting broader trends"
    - Stage 3: "Universal Translation - Converting to brand-agnostic lessons"
    - Stage 4: "Brand Contextualization - Applying to [Brand Name]"
    - Stage 5: "Opportunity Generation - Creating 5 actionable innovations"
  - [ ] Display current stage name and description
  - [ ] Show status message (e.g., "Extracting broader trends from selected tracks...")
  - [ ] Add progress spinner or pulse animation
  - [ ] When `status === "complete"`, replace with `<Button>` component
  - [ ] Button text: "View Opportunities →"
  - [ ] Button onClick: `router.push(\`/results/${runId}\`)`

- [ ] **Task 5: Error handling** (AC: 11)
  - [ ] Add try-catch to `pollStatus()` function
  - [ ] If 404 response: Set error state "Pipeline not found"
  - [ ] If `status === "error"`: Set error state "Pipeline failed"
  - [ ] If network error: Retry once after 5 seconds, then set error state
  - [ ] Create error UI: Display error message with "Back to Upload" link
  - [ ] Stop polling when error occurs

- [ ] **Task 6: Testing and verification** (AC: 10, 12)
  - [ ] Test polling starts on mount (check network tab for API calls)
  - [ ] Test polling stops when status is "complete" (verify no more API calls)
  - [ ] Test component unmount cleanup (use React DevTools)
  - [ ] Test stage boxes update correctly (manually watch progression)
  - [ ] Test Stage 1 tracks display when data arrives
  - [ ] Test "View Opportunities" button redirects correctly
  - [ ] Test error handling (404, error status, network failure)
  - [ ] Manual E2E: Upload PDF → Launch → Verify real-time updates → Results

---

## Dev Notes

### Architecture Context

**Page Location:** `app/pipeline/[runId]/page.tsx` (Next.js App Router dynamic route)

**API Integration:**
- Endpoint: `/api/status/[runId]` (from Story 3.1)
- Response: `{ run_id, status, current_stage, stage1_data? }`
- Polling interval: 5 seconds (5000ms)

**Stage Data Mapping:**
```typescript
const stages = [
  { number: 1, name: "Tracks", description: "Track Division - Selected 2 inspiration tracks" },
  { number: 2, name: "Signals", description: "Signal Amplification - Extracting broader trends" },
  { number: 3, name: "Lessons", description: "Universal Translation - Converting to brand-agnostic lessons" },
  { number: 4, name: "Context", description: "Brand Contextualization - Applying to [Brand Name]" },
  { number: 5, name: "Opport.", description: "Opportunity Generation - Creating 5 actionable innovations" }
]
```

**Stage 1 JSON Structure (from Story 3.2):**
```typescript
interface Stage1Data {
  selected_tracks: [1, 2]
  track_1: {
    title: string
    summary: string
    icon_url: string
  }
  track_2: {
    title: string
    summary: string
    icon_url: string
  }
  completed_at: string
}
```

### Implementation Patterns

**Polling Hook:**
```typescript
'use client'
import { useEffect, useState } from 'react'
import { useRouter, useParams } from 'next/navigation'

export default function PipelinePage() {
  const params = useParams()
  const router = useRouter()
  const runId = params.runId as string

  const [status, setStatus] = useState<'running' | 'complete' | 'error'>('running')
  const [currentStage, setCurrentStage] = useState<number>(0)
  const [stage1Data, setStage1Data] = useState<any>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    let timeoutId: NodeJS.Timeout

    const pollStatus = async () => {
      try {
        const response = await fetch(`/api/status/${runId}`)
        if (!response.ok) {
          setStatus('error')
          setLoading(false)
          return
        }

        const data = await response.json()
        setStatus(data.status)
        setCurrentStage(data.current_stage)
        setStage1Data(data.stage1_data)
        setLoading(false)

        if (data.status === 'running') {
          timeoutId = setTimeout(pollStatus, 5000)
        }
      } catch (error) {
        console.error('Polling error:', error)
        setStatus('error')
        setLoading(false)
      }
    }

    pollStatus()

    return () => {
      if (timeoutId) clearTimeout(timeoutId)
    }
  }, [runId])

  // Render UI...
}
```

**Stage Box Component:**
```typescript
interface StageBoxProps {
  stageNumber: number
  stageName: string
  status: 'completed' | 'running' | 'pending'
}

function StageBox({ stageNumber, stageName, status }: StageBoxProps) {
  const statusIcon = {
    completed: '✓',
    running: '⏳',
    pending: '⌛'
  }[status]

  const statusClass = {
    completed: 'bg-green-500 text-white',
    running: 'bg-blue-500 text-white animate-pulse border-2 border-blue-700',
    pending: 'bg-gray-300 text-gray-500 opacity-50'
  }[status]

  return (
    <div className={`flex flex-col items-center p-4 rounded-lg ${statusClass}`}>
      <span className="text-sm font-semibold">Stage {stageNumber}</span>
      <span className="text-xs">{stageName}</span>
      <span className="text-2xl mt-2">{statusIcon}</span>
    </div>
  )
}
```

**Track Card Component:**
```typescript
import { Card } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'

interface TrackCardProps {
  trackNumber: number
  title: string
  summary: string
}

function TrackCard({ trackNumber, title, summary }: TrackCardProps) {
  return (
    <Card className="p-6 relative">
      <div className="absolute top-4 right-4">
        <Badge variant="default" className="bg-green-500">
          ✓ Selected
        </Badge>
      </div>
      <h3 className="text-lg font-semibold mb-2">
        Track {trackNumber}: {title}
      </h3>
      <p className="text-sm text-gray-700">{summary}</p>
    </Card>
  )
}
```

### Source Tree (Relevant Files)

**Files to Create:**
- `app/pipeline/[runId]/page.tsx` - Main pipeline viewer page
- `components/pipeline/StageBox.tsx` - Stage status box component
- `components/pipeline/TrackCard.tsx` - Stage 1 track card component
- `components/pipeline/DetailPanel.tsx` - Current stage detail panel

**Files to Read (Existing):**
- `/api/status/[runId]` endpoint (from Story 3.1)
- shadcn/ui components: `Card`, `Badge`, `Button`, `Skeleton`

**Component Imports:**
```typescript
import { Card, CardContent } from '@/components/ui/card'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { Skeleton } from '@/components/ui/skeleton'
```

### Critical Constraints

**Polling Management:**
- Must cleanup `setTimeout` on unmount (memory leak prevention)
- Must stop polling when status is "complete" or "error"
- Must handle network failures gracefully (retry once)

**UI Consistency:**
- Match vertical pipeline design from PRD Section 4.3
- Match track division design from `docs/image/track-division.png`
- Use shadcn/ui components for consistent styling

**Browser Compatibility:**
- Modern browsers only (Chrome, Safari, Firefox)
- Basic mobile responsive support

### Risk Mitigation

**Primary Risk:** Polling creates memory leaks if not cleaned up
- **Mitigation:** Use `useEffect` cleanup function, test with React DevTools
- **Fallback:** Manual "Check Status" button instead of auto-polling

**Secondary Risk:** Stage 1 JSON data doesn't arrive
- **Mitigation:** Show skeleton loaders, handle null gracefully
- **Fallback:** Display "Processing..." message without track cards

---

## Testing

### Test File Locations
- Component tests: `__tests__/components/pipeline/` directory
- Page tests: `__tests__/pages/pipeline/` directory

### Testing Standards
- Use Jest + React Testing Library for component tests
- Test polling behavior with mock timers
- Test cleanup on unmount (no memory leaks)
- Manual E2E testing required

### Testing Framework
```typescript
import { render, screen, waitFor } from '@testing-library/react'
import PipelinePage from '@/app/pipeline/[runId]/page'

describe('PipelinePage', () => {
  it('should poll status every 5 seconds', async () => {
    // Mock fetch
    global.fetch = jest.fn(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ status: 'running', current_stage: 1 })
      })
    )

    render(<PipelinePage />)

    await waitFor(() => {
      expect(fetch).toHaveBeenCalledTimes(1)
    })

    jest.advanceTimersByTime(5000)

    await waitFor(() => {
      expect(fetch).toHaveBeenCalledTimes(2)
    })
  })

  it('should stop polling when complete', async () => {
    global.fetch = jest.fn(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve({ status: 'complete', current_stage: 5 })
      })
    )

    render(<PipelinePage />)

    await waitFor(() => {
      expect(fetch).toHaveBeenCalledTimes(1)
    })

    jest.advanceTimersByTime(10000)

    expect(fetch).toHaveBeenCalledTimes(1) // No more calls
  })
})
```

### Specific Testing Requirements
1. Test polling starts on mount
2. Test polling stops when status is "complete"
3. Test cleanup on unmount (verify no timeouts running)
4. Test stage boxes render with correct status
5. Test track cards display when `stage1_data` present
6. Test error states (404, network error, pipeline error)
7. Manual E2E: Upload → Launch → Monitor → Results

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-19 | 1.0 | Initial story creation | John (PM Agent) |

---

## Dev Agent Record

### Agent Model Used
*To be populated by dev agent*

### Debug Log References
*To be populated by dev agent*

### Completion Notes List
*To be populated by dev agent*

### File List
*To be populated by dev agent*

---

## QA Results

*To be populated by QA agent after story completion*
