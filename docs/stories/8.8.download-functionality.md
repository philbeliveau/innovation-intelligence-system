# Story 8.8: Download Functionality

**Epic:** Epic 8 - Pipeline Visualization Refactor
**Priority:** P2
**Estimated Time:** 3-4 hours

---

## Status

**Approved**

---

## Story

**As a** CPG Innovation Manager using the Innovation Intelligence Pipeline,
**I want** to download individual sparks or all sparks as PDF documents,
**so that** I can share innovation opportunities with stakeholders and archive insights offline.

---

## Acceptance Criteria

### 1. Download All Sparks Button (State 3)
- Button location: Fixed action bar at bottom of State 3 (SparksGrid)
- Button text: "Download All Sparks (PDF)"
- Button style: Teal background (#5B9A99), white text, rounded corners
- Button width: Full width on mobile, auto on desktop
- Click behavior: Triggers `GET /api/pipeline/[runId]/download/all`
- Loading state: Button disabled, shows spinner + "Generating PDF..."
- Success feedback: PDF downloads with filename `sparks-[runId]-[timestamp].pdf`
- Error handling: Toast notification "Download failed, please try again"

### 2. Download Single Spark Button (State 4)
- Button location: Top-right of ExpandedSparkDetail component
- Button text: "Download PDF" (with download icon)
- Button style: Secondary outline style (teal border, white background)
- Click behavior: Triggers `GET /api/pipeline/[runId]/download/spark/[sparkId]`
- Loading state: Button disabled, shows spinner
- Success feedback: PDF downloads with filename `spark-[sparkId]-[title-slug].pdf`
- Error handling: Toast notification "Download failed, please try again"

### 3. Backend API Endpoint: Download All Sparks
- Endpoint: `GET /api/pipeline/[runId]/download/all`
- Query params: Optional `?format=pdf` (default) or `?format=json`
- Response: PDF file (Content-Type: `application/pdf`)
- PDF structure:
  - Cover page: Pipeline run ID, date, total sparks count
  - Page per spark: Title, hero image, full markdown content
  - Table of contents: Links to each spark
  - Footer: Page numbers, generated timestamp
- Filename: `sparks-[runId]-YYYY-MM-DD.pdf`
- Max file size: 50MB (warn if exceeded, suggest downloading individually)

### 4. Backend API Endpoint: Download Single Spark
- Endpoint: `GET /api/pipeline/[runId]/download/spark/[sparkId]`
- Query params: Optional `?format=pdf` (default) or `?format=json`
- Response: PDF file (Content-Type: `application/pdf`)
- PDF structure:
  - Title page: Spark title, hero image
  - Content pages: Full markdown rendered to PDF
  - Metadata footer: Pipeline run ID, spark ID, generated date
- Filename: `spark-[sparkId]-[title-slug].pdf` (slug: lowercase, hyphens, max 50 chars)
- Max file size: 10MB

### 5. PDF Generation Quality
- Typography: Professional font (Inter or system sans-serif)
- Images: Embedded at high resolution (300 DPI)
- Markdown rendering: Preserve formatting (headings, lists, bold, italic, links)
- Page breaks: Avoid orphaned headings, keep related content together
- Color scheme: Match BOI branding (teal accents, gray text)
- Print-friendly: High contrast, no dark backgrounds

### 6. Download Progress Feedback
- Frontend: Show loading state immediately on button click
- Frontend: Disable button during download (prevent double-click)
- Frontend: Show toast notification on success ("PDF downloaded successfully")
- Frontend: Show error toast on failure with retry button
- Backend: Generate PDF asynchronously if >10 sparks (return job ID, poll for completion)
- Backend: Cache generated PDFs for 1 hour (avoid regenerating same PDF)

### 7. Error Handling
- Network timeout (>30s): Show "Download timed out, please try again"
- 404 error: "Sparks not found, pipeline may still be processing"
- 500 error: "Server error generating PDF, please try again later"
- Large file warning: "PDF is large (>20MB), download may take a moment"
- Retry mechanism: Allow user to retry failed downloads
- Fallback: Offer JSON download if PDF generation fails

---

## Tasks / Subtasks

- [ ] Create frontend download components (AC: #1, #2)
  - [ ] Add "Download All" button to `ActionBar.tsx` (State 3)
  - [ ] Add "Download PDF" button to `ExpandedSparkDetail.tsx` (State 4)
  - [ ] Style buttons with Tailwind: Primary (teal) and secondary (outline)
  - [ ] Add download icon (use Heroicons or Lucide)
  - [ ] Test button placement on mobile and desktop

- [ ] Implement download trigger logic (AC: #1, #2, #6)
  - [ ] Create `innovation-web/lib/download.ts` utility
  - [ ] Function: `downloadAllSparks(runId: string)` → triggers API call
  - [ ] Function: `downloadSingleSpark(runId: string, sparkId: string)` → triggers API call
  - [ ] Handle loading state: Set button to disabled + spinner
  - [ ] Handle success: Trigger browser download
  - [ ] Handle error: Show toast notification with retry option

- [ ] Create toast notification system (AC: #6, #7)
  - [ ] Install `react-hot-toast` or use shadcn/ui Toast component
  - [ ] Configure toast position: Bottom-right on desktop, top-center on mobile
  - [ ] Success toast: Green background, checkmark icon, auto-dismiss (3s)
  - [ ] Error toast: Red background, error icon, manual dismiss
  - [ ] Warning toast: Yellow background, warning icon, auto-dismiss (5s)

- [ ] Build backend API: Download All Sparks (AC: #3)
  - [ ] Create file: `innovation-web/app/api/pipeline/[runId]/download/all/route.ts`
  - [ ] Fetch all sparks from Prisma: `prisma.opportunityCard.findMany({ where: { runId } })`
  - [ ] Generate PDF using `@react-pdf/renderer` or `puppeteer`
  - [ ] Include cover page with run metadata
  - [ ] Include table of contents with page numbers
  - [ ] Render each spark as PDF pages (title + hero + markdown)
  - [ ] Set response headers: `Content-Type: application/pdf`, `Content-Disposition: attachment; filename=...`
  - [ ] Return PDF as stream

- [ ] Build backend API: Download Single Spark (AC: #4)
  - [ ] Create file: `innovation-web/app/api/pipeline/[runId]/download/spark/[sparkId]/route.ts`
  - [ ] Fetch spark from Prisma: `prisma.opportunityCard.findUnique({ where: { id: sparkId } })`
  - [ ] Validate spark belongs to runId (security check)
  - [ ] Generate PDF: Title page + markdown content
  - [ ] Slugify title for filename (remove special chars, max 50 chars)
  - [ ] Set response headers: `Content-Type: application/pdf`, `Content-Disposition: attachment`
  - [ ] Return PDF as stream

- [ ] Implement PDF generation library integration (AC: #5)
  - [ ] Option 1: Install `@react-pdf/renderer` (React-based PDF generation)
  - [ ] Option 2: Install `puppeteer` (HTML-to-PDF via headless Chrome)
  - [ ] Create PDF template components (if using @react-pdf/renderer)
  - [ ] Configure typography: Inter font, 11pt body, 18pt headings
  - [ ] Embed hero images at 300 DPI
  - [ ] Render markdown to PDF: Use `react-markdown` + @react-pdf components
  - [ ] Test page breaks: Avoid orphaned headings

- [ ] Add PDF caching (AC: #6)
  - [ ] Create cache directory: `backend/cache/pdfs/` (or use Vercel Blob)
  - [ ] Cache key: `${runId}-all-sparks` or `${runId}-${sparkId}`
  - [ ] Cache duration: 1 hour
  - [ ] Check cache before generating: Return cached PDF if exists
  - [ ] Invalidate cache on pipeline re-run or spark update
  - [ ] Test cache hit/miss performance

- [ ] Implement async PDF generation for large files (AC: #6)
  - [ ] If >10 sparks: Generate PDF asynchronously
  - [ ] Return job ID: `{ jobId: "abc123", status: "processing" }`
  - [ ] Frontend: Poll `GET /api/pipeline/[runId]/download/job/[jobId]`
  - [ ] Backend: Store job status in Prisma or Redis
  - [ ] When complete: Return PDF URL (Vercel Blob or S3)
  - [ ] Frontend: Auto-download PDF when job completes

- [ ] Add error handling and retries (AC: #7)
  - [ ] Backend: Wrap PDF generation in try/catch
  - [ ] Backend: Return 500 with JSON error: `{ error: "PDF generation failed" }`
  - [ ] Frontend: Detect timeout (>30s) and show error toast
  - [ ] Frontend: Show 404 error if sparks not found
  - [ ] Frontend: Add retry button in error toast
  - [ ] Frontend: Fallback to JSON download if PDF fails
  - [ ] Test error scenarios: Network failure, server error, timeout

- [ ] Add download analytics (optional) (AC: #6)
  - [ ] Log download events: `prisma.downloadLog.create({ runId, sparkId, type: 'all' | 'single' })`
  - [ ] Track download counts per run
  - [ ] Track download failures for monitoring
  - [ ] Create database migration for `DownloadLog` table (if needed)

- [ ] Integration testing (AC: #1-7)
  - [ ] Test Download All: 1, 5, 10, 20 sparks
  - [ ] Test Download Single: Various spark lengths (short, long)
  - [ ] Test error cases: Network timeout, 404, 500
  - [ ] Test retry functionality
  - [ ] Test caching: Generate PDF twice, second should be instant
  - [ ] Test async generation: >10 sparks
  - [ ] Test mobile: Download buttons work on touch devices

- [ ] Visual QA (AC: #5)
  - [ ] Verify PDF typography matches design spec
  - [ ] Verify hero images embed correctly (no blur)
  - [ ] Verify markdown renders correctly (headings, lists, links)
  - [ ] Verify page breaks are clean (no orphaned content)
  - [ ] Verify footer metadata is correct
  - [ ] Print test: PDF prints cleanly on paper

---

## Dev Notes

### Integration Points

**Frontend Components:**
- `innovation-web/components/pipeline/ActionBar.tsx` - Add Download All button
- `innovation-web/components/pipeline/ExpandedSparkDetail.tsx` - Add Download PDF button
- `innovation-web/lib/download.ts` - Download utility functions

**Backend API Routes:**
- `innovation-web/app/api/pipeline/[runId]/download/all/route.ts` - Download all sparks
- `innovation-web/app/api/pipeline/[runId]/download/spark/[sparkId]/route.ts` - Download single spark
- `innovation-web/app/api/pipeline/[runId]/download/job/[jobId]/route.ts` - Check async job status

**Database (Optional):**
- `prisma/schema.prisma` - Add `DownloadLog` model for analytics (optional)

**No Changes to Python Backend**

### Technical Details

**Download Utility (Frontend):**
```typescript
// lib/download.ts
import { toast } from 'react-hot-toast'

export const downloadAllSparks = async (runId: string) => {
  try {
    toast.loading('Generating PDF...', { id: 'download-all' })

    const response = await fetch(`/api/pipeline/${runId}/download/all`)

    if (!response.ok) {
      throw new Error(`Download failed: ${response.statusText}`)
    }

    const blob = await response.blob()
    const url = window.URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `sparks-${runId}-${new Date().toISOString().split('T')[0]}.pdf`
    document.body.appendChild(a)
    a.click()
    window.URL.revokeObjectURL(url)
    document.body.removeChild(a)

    toast.success('PDF downloaded successfully', { id: 'download-all' })
  } catch (error) {
    console.error('Download error:', error)
    toast.error('Download failed. Please try again.', { id: 'download-all' })
  }
}

export const downloadSingleSpark = async (runId: string, sparkId: string, title: string) => {
  try {
    toast.loading('Generating PDF...', { id: `download-${sparkId}` })

    const response = await fetch(`/api/pipeline/${runId}/download/spark/${sparkId}`)

    if (!response.ok) {
      throw new Error(`Download failed: ${response.statusText}`)
    }

    const blob = await response.blob()
    const url = window.URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `spark-${slugify(title)}.pdf`
    document.body.appendChild(a)
    a.click()
    window.URL.revokeObjectURL(url)
    document.body.removeChild(a)

    toast.success('PDF downloaded successfully', { id: `download-${sparkId}` })
  } catch (error) {
    console.error('Download error:', error)
    toast.error('Download failed. Please try again.', { id: `download-${sparkId}` })
  }
}

const slugify = (text: string) => {
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '')
    .substring(0, 50)
}
```

**Backend API: Download All (Option 1: @react-pdf/renderer):**
```typescript
// app/api/pipeline/[runId]/download/all/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { renderToStream } from '@react-pdf/renderer'
import { AllSparksPDF } from '@/components/pdf/AllSparksPDF'

export async function GET(
  request: NextRequest,
  { params }: { params: { runId: string } }
) {
  try {
    const { runId } = params

    // Fetch all sparks
    const sparks = await prisma.opportunityCard.findMany({
      where: { runId },
      orderBy: { createdAt: 'asc' }
    })

    if (sparks.length === 0) {
      return NextResponse.json(
        { error: 'No sparks found for this pipeline run' },
        { status: 404 }
      )
    }

    // Generate PDF
    const pdfStream = await renderToStream(<AllSparksPDF sparks={sparks} runId={runId} />)

    const filename = `sparks-${runId}-${new Date().toISOString().split('T')[0]}.pdf`

    return new NextResponse(pdfStream as any, {
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${filename}"`
      }
    })
  } catch (error) {
    console.error('PDF generation error:', error)
    return NextResponse.json(
      { error: 'Failed to generate PDF' },
      { status: 500 }
    )
  }
}
```

**PDF Component (@react-pdf/renderer):**
```typescript
// components/pdf/AllSparksPDF.tsx
import { Document, Page, Text, View, Image, StyleSheet } from '@react-pdf/renderer'

const styles = StyleSheet.create({
  page: {
    padding: 30,
    fontFamily: 'Helvetica'
  },
  coverPage: {
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    height: '100%'
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    marginBottom: 20,
    color: '#5B9A99'
  },
  sparkTitle: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    color: '#1F2937'
  },
  sparkImage: {
    width: '100%',
    height: 300,
    objectFit: 'cover',
    marginBottom: 20
  },
  content: {
    fontSize: 11,
    lineHeight: 1.6,
    color: '#374151'
  },
  pageNumber: {
    position: 'absolute',
    bottom: 20,
    right: 30,
    fontSize: 10,
    color: '#9CA3AF'
  }
})

interface Props {
  sparks: Array<{
    id: string
    title: string
    heroImageUrl?: string
    fullContent: string
  }>
  runId: string
}

export const AllSparksPDF = ({ sparks, runId }: Props) => (
  <Document>
    {/* Cover Page */}
    <Page size="A4" style={styles.page}>
      <View style={styles.coverPage}>
        <Text style={styles.title}>Innovation Sparks</Text>
        <Text>Pipeline Run: {runId}</Text>
        <Text>Total Sparks: {sparks.length}</Text>
        <Text>Generated: {new Date().toLocaleDateString()}</Text>
      </View>
    </Page>

    {/* Spark Pages */}
    {sparks.map((spark, index) => (
      <Page key={spark.id} size="A4" style={styles.page}>
        <Text style={styles.sparkTitle}>{spark.title}</Text>
        {spark.heroImageUrl && (
          <Image src={spark.heroImageUrl} style={styles.sparkImage} />
        )}
        <Text style={styles.content}>{spark.fullContent}</Text>
        <Text style={styles.pageNumber}>{index + 2}</Text>
      </Page>
    ))}
  </Document>
)
```

**Backend API: Download Single Spark:**
```typescript
// app/api/pipeline/[runId]/download/spark/[sparkId]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { renderToStream } from '@react-pdf/renderer'
import { SingleSparkPDF } from '@/components/pdf/SingleSparkPDF'

export async function GET(
  request: NextRequest,
  { params }: { params: { runId: string; sparkId: string } }
) {
  try {
    const { runId, sparkId } = params

    const spark = await prisma.opportunityCard.findUnique({
      where: { id: sparkId }
    })

    if (!spark || spark.runId !== runId) {
      return NextResponse.json(
        { error: 'Spark not found' },
        { status: 404 }
      )
    }

    const pdfStream = await renderToStream(<SingleSparkPDF spark={spark} />)

    const slugTitle = spark.title
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '')
      .substring(0, 50)

    const filename = `spark-${slugTitle}.pdf`

    return new NextResponse(pdfStream as any, {
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${filename}"`
      }
    })
  } catch (error) {
    console.error('PDF generation error:', error)
    return NextResponse.json(
      { error: 'Failed to generate PDF' },
      { status: 500 }
    )
  }
}
```

### Files Referenced

- `docs/front-end-spec.md` (lines 630-635, 1070-1071) - Download endpoints
- `prisma/schema.prisma` - OpportunityCard model

### Dependencies

**NPM Packages:**
- `@react-pdf/renderer` (v3.x) - React-based PDF generation
  - Alternative: `puppeteer` for HTML-to-PDF (heavier, requires Chrome)
- `react-hot-toast` (v2.x) - Toast notifications
  - Alternative: shadcn/ui Toast component

**Depends On:**
- Story 8.1: Pipeline State Machine Foundation
- Story 8.4: State 3 - Sparks Grid (ActionBar component)
- Story 8.5: State 4 - Detail View (ExpandedSparkDetail component)

### Testing

#### Test File Location
- `innovation-web/__tests__/api/download-all.test.ts`
- `innovation-web/__tests__/api/download-single.test.ts`
- `innovation-web/__tests__/lib/download.test.ts`

#### Testing Standards

**1. Frontend Download Tests:**
- Click "Download All" → API called with correct runId
- Click "Download PDF" → API called with correct runId + sparkId
- Loading state shows during download
- Success toast appears on completion
- Error toast appears on failure

**2. Backend API Tests:**
- Download all with 0 sparks → 404 error
- Download all with 5 sparks → PDF generated, correct filename
- Download single spark → PDF generated, slugified filename
- Invalid sparkId → 404 error
- Spark belongs to different runId → 404 error (security)

**3. PDF Quality Tests:**
- Generated PDF opens in Acrobat/Preview without errors
- Hero images render at high resolution (no blur)
- Markdown formatting preserved (headings, bold, lists)
- Page breaks are clean (no orphaned headings)
- Footer metadata is correct

**4. Performance Tests:**
- Download 1 spark: <2s
- Download 10 sparks: <10s
- Download 20 sparks: <30s (or async job created)
- Cached PDF: <500ms

**5. Error Handling Tests:**
- Network timeout (mock): Error toast shown
- 404 response: "Sparks not found" toast
- 500 response: "Server error" toast
- Retry button: Reattempts download

**6. Caching Tests:**
- First download: PDF generated fresh
- Second download (within 1h): Cached PDF returned
- After 1h: Cache expired, new PDF generated

#### Testing Framework
- Jest + React Testing Library for frontend
- Vitest or Jest for backend API tests
- Manual testing for PDF quality (visual inspection)

#### Specific Testing Requirements

**Test: Download All API**
```typescript
test('GET /api/pipeline/[runId]/download/all returns PDF', async () => {
  // Create mock sparks in database
  await prisma.opportunityCard.createMany({
    data: [
      { runId: 'test-run', title: 'Spark 1', fullContent: 'Content 1' },
      { runId: 'test-run', title: 'Spark 2', fullContent: 'Content 2' }
    ]
  })

  const response = await fetch('/api/pipeline/test-run/download/all')

  expect(response.status).toBe(200)
  expect(response.headers.get('Content-Type')).toBe('application/pdf')
  expect(response.headers.get('Content-Disposition')).toContain('sparks-test-run')

  const blob = await response.blob()
  expect(blob.size).toBeGreaterThan(0) // PDF is not empty
})
```

**Test: Download Single Spark API**
```typescript
test('GET /api/pipeline/[runId]/download/spark/[sparkId] returns PDF', async () => {
  const spark = await prisma.opportunityCard.create({
    data: {
      runId: 'test-run',
      title: 'Test Spark',
      fullContent: 'Full content here'
    }
  })

  const response = await fetch(`/api/pipeline/test-run/download/spark/${spark.id}`)

  expect(response.status).toBe(200)
  expect(response.headers.get('Content-Type')).toBe('application/pdf')
  expect(response.headers.get('Content-Disposition')).toContain('spark-test-spark')
})
```

**Test: Frontend Download Utility**
```typescript
test('downloadAllSparks triggers download', async () => {
  global.fetch = jest.fn().mockResolvedValue({
    ok: true,
    blob: async () => new Blob(['fake pdf'], { type: 'application/pdf' })
  })

  const createElementSpy = jest.spyOn(document, 'createElement')

  await downloadAllSparks('test-run')

  expect(fetch).toHaveBeenCalledWith('/api/pipeline/test-run/download/all')
  expect(createElementSpy).toHaveBeenCalledWith('a')

  createElementSpy.mockRestore()
})
```

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-25 | 1.0 | Initial story creation for Epic 8 polish phase | John (PM) |

---

## Dev Agent Record

### Agent Model Used
*To be populated by dev agent*

### Debug Log References
*To be populated by dev agent*

### Completion Notes List
*To be populated by dev agent*

### File List
*To be populated by dev agent*

---

## QA Results

*To be populated by QA agent*
