# Story 3.1: API Routes for Pipeline Execution

---

## Status

**Ready for Review**

---

## Story

**As a** web application user,
**I want** to trigger the Python pipeline from the web interface and check its execution status,
**so that** I can process uploaded documents and monitor progress in real-time without using the CLI.

---

## Acceptance Criteria

### Pipeline Execution API (Primary Focus)

1. POST `/api/run` endpoint accepts JSON payload with `blob_url` and `upload_id`, downloads PDF from Vercel Blob, reads company ID from cookie, and executes Python pipeline in background subprocess
2. POST `/api/run` returns JSON response `{ run_id, status: "running" }` immediately (non-blocking execution)
3. Subprocess execution uses non-blocking `exec()` to avoid Vercel timeout
4. Error handling logs subprocess errors to console without crashing API route

### Status Monitoring API

5. GET `/api/status/[runId]` endpoint reads log file from `data/test-outputs/{runId}/logs/pipeline.log` and parses current stage (0-5)
6. GET `/api/status/[runId]` returns JSON: `{ run_id, status, current_stage, stage1_data? }` with Stage 1 JSON data when available
7. Stage detection function correctly identifies pipeline progress from log messages

### Company Context API

8. GET `/api/onboarding/current-company` reads company ID from cookie and returns company data
9. POST `/api/onboarding/set-company` creates HTTP-only cookie with company ID (implemented in Story 1.1 - verify compatibility)

### Quality & Compatibility

10. All endpoints return appropriate HTTP status codes (400 for validation errors, 404 for missing resources, 500 for server errors)
11. Existing Python CLI execution (`--batch` mode) continues working unchanged after integration

### Dependencies from Previous Stories

**Note:** Story 2.1's `/api/analyze-document` endpoint is already implemented and not part of this story.

---

## Tasks / Subtasks

- [x] **Task 1: Create `/api/run` endpoint** (AC: 1, 2, 7)
  - [x] Create `app/api/run/route.ts` file
  - [x] Add request validation for `blob_url` and `upload_id`
  - [x] Read company ID from HTTP-only cookie
  - [x] Download PDF from Vercel Blob to `/tmp/{run_id}.pdf`
  - [x] Generate unique `run_id` using `Date.now()`
  - [x] Execute Python subprocess: `python scripts/run_pipeline.py --input-file /tmp/{run_id}.pdf --brand {company_id} --run-id {run_id}`
  - [x] Use `child_process.exec()` (non-blocking)
  - [x] Log subprocess stdout/stderr to console
  - [x] Return JSON: `{ run_id, status: "running" }`

- [x] **Task 2: Create `/api/status/[runId]` endpoint** (AC: 5, 6, 7, 10)
  - [x] Create `app/api/status/[runId]/route.ts` file
  - [x] Extract `runId` from URL parameter
  - [x] Read log file: `data/test-outputs/{runId}/logs/pipeline.log`
  - [x] Implement `detectStageFromLog()` function (parse for "Starting Stage X" and "Stage X execution completed")
  - [x] Read Stage 1 JSON if `current_stage >= 1`: `data/test-outputs/{runId}/stage1/inspirations.json`
  - [x] Return JSON: `{ run_id, status, current_stage, stage1_data }`
  - [x] Return 404 if log file doesn't exist
  - [x] Return status "error" if log contains error indicators

- [x] **Task 3: Create onboarding API routes** (AC: 8, 9)
  - [x] Create `app/api/onboarding/current-company/route.ts`
  - [x] Read company ID from cookie using `cookies().get('company_id')`
  - [x] Load brand profile YAML from `data/brand-profiles/{company_id}.yaml`
  - [x] Return `{ company_id, company_name }` or 401 error if not set
  - [x] **Note:** `POST /api/onboarding/set-company` already exists from Story 1.1
  - [x] Verify compatibility with Story 1.1's cookie implementation

- [x] **Task 4: Error handling and validation** (AC: 4, 10)
  - [x] Add try-catch blocks to all endpoints
  - [x] Return proper error responses with JSON `{ error: string }`
  - [x] Log all errors to console with context
  - [x] Add input validation for all request bodies
  - [x] Handle missing files gracefully (return error, don't crash)

- [x] **Task 5: Testing and verification** (AC: 11)
  - [x] Test `/api/run` with Postman/curl (verify run_id returned)
  - [x] Test `/api/status` with existing run ID (verify stage detection)
  - [x] Test `/api/status` with non-existent run ID (verify 404)
  - [x] Verify `/api/analyze-document` from Story 2.1 works (integration test)
  - [x] Run existing batch mode: `python scripts/run_pipeline.py --batch`
  - [x] Verify all 4 test runs complete successfully (no regression)

---

## Dev Notes

### Architecture Context

**API Routes Location:** `app/api/` directory (Next.js 15 App Router pattern)

**File-Based Communication:**
- Pipeline writes logs to: `data/test-outputs/{run_id}/logs/pipeline.log`
- Stage 1 writes JSON to: `data/test-outputs/{run_id}/stage1/inspirations.json`
- API routes read these files to provide status updates

**Python Pipeline Integration:**
- Entry point: `scripts/run_pipeline.py`
- New CLI arguments (from Story 3.2): `--input-file`, `--run-id`
- Existing CLI arguments: `--batch`, `--input`, `--brand`
- Pipeline must run unchanged from both CLI and web interface

**Environment Variables (from `.env.local`):**
```
OPENROUTER_API_KEY=sk-or-v1-...
OPENROUTER_BASE_URL=https://openrouter.ai/api/v1
LLM_MODEL=anthropic/claude-sonnet-4.5
BLOB_READ_WRITE_TOKEN=vercel_blob_...
```

### Implementation Patterns

**Subprocess Execution:**
```typescript
import { exec } from 'child_process'

const command = `cd ${process.cwd()} && python scripts/run_pipeline.py --input-file ${tmpPath} --brand ${brand_id} --run-id ${run_id}`

exec(command, (error, stdout, stderr) => {
  if (error) console.error(`Pipeline error for ${run_id}:`, error)
  console.log(`Pipeline stdout: ${stdout}`)
  console.error(`Pipeline stderr: ${stderr}`)
})
```

**Log Parsing Function:**
```typescript
function detectStageFromLog(logContent: string): number {
  if (logContent.includes('Stage 5 execution completed')) return 5
  if (logContent.includes('Starting Stage 5')) return 5
  if (logContent.includes('Stage 4 execution completed')) return 4
  if (logContent.includes('Starting Stage 4')) return 4
  if (logContent.includes('Stage 3 execution completed')) return 3
  if (logContent.includes('Starting Stage 3')) return 3
  if (logContent.includes('Stage 2 execution completed')) return 2
  if (logContent.includes('Starting Stage 2')) return 2
  if (logContent.includes('Stage 1 execution completed')) return 1
  if (logContent.includes('Starting Stage 1')) return 1
  return 0
}
```

**LLM Integration:**
```typescript
import { ChatOpenAI } from '@langchain/openai'

const llm = new ChatOpenAI({
  modelName: process.env.LLM_MODEL || 'anthropic/claude-sonnet-4.5',
  openAIApiKey: process.env.OPENROUTER_API_KEY,
  configuration: {
    baseURL: 'https://openrouter.ai/api/v1'
  }
})

const result = await llm.invoke(analysisPrompt)
const analysis = JSON.parse(result.content as string)
```

**Error Response Pattern:**
```typescript
import { NextResponse } from 'next/server'

return NextResponse.json(
  { error: 'Invalid file type' },
  { status: 400 }
)
```

### Source Tree (Relevant Files)

**Files to Create:**
- `app/api/run/route.ts` - Pipeline execution endpoint
- `app/api/status/[runId]/route.ts` - Status polling endpoint
- `app/api/onboarding/current-company/route.ts` - Company context retrieval

**Files Already Implemented (Dependencies):**
- `app/api/onboarding/set-company/route.ts` - Created in Story 1.1
- `app/api/analyze-document/route.ts` - Created in Story 2.1
- `app/api/upload/route.ts` - Created in Story 1.2

**Files to Read (Existing):**
- `scripts/run_pipeline.py` - Pipeline entry point (modified in Story 3.2)
- `data/brand-profiles/{company_id}.yaml` - Brand profile data
- `data/test-outputs/{run_id}/logs/pipeline.log` - Log file for status
- `data/test-outputs/{run_id}/stage1/inspirations.json` - Stage 1 output (from Story 3.2)

**Dependencies (Already Installed):**
- `pdf-parse` - Installed in Story 2.1
- `@langchain/openai` - Installed in Story 2.1
- `yaml` - Installed in Story 1.1

### Critical Constraints

**Vercel Deployment:**
- API routes timeout after 300 seconds (5 minutes)
- Must use non-blocking subprocess execution
- Only `/tmp` and project directory are writable
- Python 3.10+ must be available in deployment environment

**Backward Compatibility:**
- Python CLI must work unchanged
- Existing test outputs must remain valid
- No changes to Stages 2-5 (only Stage 1 gets JSON output in Story 3.2)

### Risk Mitigation

**Primary Risk:** Python subprocess execution fails on Vercel
- **Mitigation:** Use non-blocking `exec()`, test early
- **Fallback:** Run pipeline on external server, trigger via webhook

**Secondary Risk:** Log parsing fails to detect stages
- **Mitigation:** Add explicit status markers in Python logging
- **Fallback:** Write `status.json` file from Python

---

## Testing

### Test File Locations
- Integration tests: `__tests__/api/` directory
- Unit tests for utilities: `__tests__/utils/` directory

### Testing Standards
- Use Jest for unit/integration tests
- Use Postman/curl for manual API testing
- Test all error scenarios (400, 404, 500)
- Verify no regression in Python CLI (`--batch` mode)

### Testing Framework
```typescript
// Example test structure
describe('POST /api/run', () => {
  it('should return run_id and status running', async () => {
    // Test implementation
  })

  it('should return 400 for missing blob_url', async () => {
    // Test implementation
  })
})
```

### Specific Testing Requirements
1. Test subprocess execution (verify non-blocking)
2. Test log file parsing with sample logs
3. Test Stage 1 JSON reading with missing file
4. Test LLM extraction with actual PDF
5. Regression test: Run `python scripts/run_pipeline.py --batch` after API implementation

---

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-19 | 1.0 | Initial story creation | John (PM Agent) |

---

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

### Debug Log References
- Fixed Next.js Turbopack workspace root detection issue by adding explicit `turbopack.root` configuration in next.config.ts
- Resolved process.cwd() path resolution problems caused by multiple package-lock.json files in user directory

### Completion Notes List
- Created `/api/run` endpoint with non-blocking subprocess execution, Vercel Blob integration, and cookie-based company authentication
- Created `/api/status/[runId]` endpoint with log parsing, stage detection, and Stage 1 JSON data retrieval
- Verified compatibility with existing `/api/onboarding/current-company` and `/api/onboarding/set-company` routes from Story 1.1
- Implemented comprehensive error handling with proper HTTP status codes (400, 401, 404, 500)
- All endpoints tested successfully with curl requests
- Added Turbopack root configuration to next.config.ts to fix workspace detection

### File List
- `innovation-web/app/api/run/route.ts` (created)
- `innovation-web/app/api/status/[runId]/route.ts` (created)
- `innovation-web/next.config.ts` (modified - added turbopack.root configuration)
- `innovation-web/app/api/onboarding/current-company/route.ts` (verified existing - no changes)
- `innovation-web/app/api/onboarding/set-company/route.ts` (verified existing - no changes)

---

## QA Results

### Review Date: 2025-10-19

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

The implementation successfully delivers the core functionality for API-based pipeline execution with proper error handling and logging. However, **critical security vulnerabilities** and **architectural concerns** require immediate attention before production deployment.

**Strengths:**
- Clean separation of concerns across three well-structured API routes
- Consistent error response format with appropriate HTTP status codes
- Good use of TypeScript strict typing (no `any` types)
- Proper input sanitization for `company_id` and `runId` parameters
- Well-documented helper functions with clear logic

**Critical Issues Found:**
- **Command injection vulnerability** in subprocess execution (FIXED during review)
- **Architectural incompatibility** with Vercel serverless platform for long-running processes
- **Zero automated test coverage** - relies entirely on manual curl testing
- **Data directory duplication** (`data/brand-profiles/` exists in two locations)
- **Missing dependency verification** - Story 3.2 (Python modifications) implementation status unclear

### Refactoring Performed

**Security Hardening (CRITICAL):**

- **File**: `app/api/run/route.ts`
  - **Change**: Replaced `exec()` with `execFile()` and added run_id validation
  - **Why**: Original implementation used shell command concatenation vulnerable to command injection attacks. Malicious `blob_url` or `run_id` could execute arbitrary code.
  - **How**:
    - Switched from `exec(command)` to `execFile('python', [script, ...args])` which prevents shell interpolation
    - Added regex validation for `run_id` format (`/^run-\d+$/`)
    - Separated arguments into array instead of string interpolation
    - **Impact:** Eliminates CWE-78 (Command Injection) vulnerability

**Documentation Improvements:**

- **File**: `app/api/status/[runId]/route.ts`
  - **Change**: Added comprehensive JSDoc comments to `detectStageFromLog()` and `detectStatusFromLog()`
  - **Why**: Coding standards (line 461-474) require JSDoc for public functions
  - **How**: Added parameter descriptions, return value documentation, and usage examples

### Compliance Check

- **Coding Standards**: ⚠️ **PARTIAL**
  - ✅ File naming conventions (route.ts pattern)
  - ✅ TypeScript strict mode (no `any` types)
  - ✅ Async/await consistency
  - ✅ Error handling in all async functions
  - ❌ Missing environment variable validation (OPENROUTER_API_KEY not checked in /api/run)
  - ✅ JSDoc for helper functions (FIXED during review)

- **Project Structure**: ❌ **VIOLATION**
  - Brand profiles duplicated in `data/brand-profiles/` and `innovation-web/data/brand-profiles/`
  - Routes use inconsistent path resolution (`..` vs no parent directory)
  - Hardcoded path traversal (`join(process.cwd(), '..')`) violates portability

- **Testing Strategy**: ❌ **NOT IMPLEMENTED**
  - Zero automated tests (unit, integration, or E2E)
  - Only manual curl/Postman testing performed
  - Missing security validation tests for input sanitization

- **All ACs Met**: ⚠️ **PARTIALLY**
  - AC 1-10: Implemented correctly
  - AC 11 (backward compatibility): NOT VERIFIED - no evidence Python CLI `--batch` mode tested after integration

### Improvements Checklist

**Completed During Review:**
- [x] Fixed command injection vulnerability by switching to `execFile()` (app/api/run/route.ts)
- [x] Added JSDoc documentation for helper functions (app/api/status/[runId]/route.ts)
- [x] Added run_id format validation (app/api/run/route.ts)

**MUST FIX Before Production:**
- [ ] **CRITICAL:** Resolve Vercel serverless incompatibility - subprocess execution will not work as designed
  - Options: (1) Deploy Python separately, (2) Use queue system with cron jobs, (3) Switch hosting platform
- [ ] Add automated test suite with minimum P0 security tests (command injection, path traversal)
- [ ] Resolve data directory duplication - standardize on single source of truth for brand profiles
- [ ] Verify Story 3.2 Python modifications are complete and tested
- [ ] Add CSRF protection for state-changing operations
- [ ] Implement pipeline execution queue or concurrency limits

**SHOULD FIX (Medium Priority):**
- [ ] Extract path resolution logic to centralized configuration module
- [ ] Add environment variable validation at application startup
- [ ] Implement rate limiting on `/api/run` endpoint
- [ ] Add request timeout to blob fetch operations
- [ ] Create integration tests for full workflow (upload → run → status → results)

**NICE TO HAVE (Low Priority):**
- [ ] Replace polling with WebSockets/SSE for real-time updates (if hosting platform allows)
- [ ] Add health check endpoint to verify Python environment
- [ ] Implement structured logging with correlation IDs
- [ ] Add OpenTelemetry tracing for pipeline debugging

### Security Review

**CRITICAL VULNERABILITIES FOUND:**

1. **Command Injection (CWE-78)** - ✅ FIXED
   - **Original Issue:** `exec()` used with string interpolation of `tmpPath` and `run_id`
   - **Risk:** Arbitrary code execution via malicious parameters
   - **Fix Applied:** Switched to `execFile()` with array arguments
   - **Verification:** TypeScript compilation passes, no shell interpolation possible

2. **Serverless Architecture Incompatibility** - ⚠️ UNRESOLVED
   - **Issue:** Vercel freezes functions after response - `execFile()` callback may never execute
   - **Risk:** Pipeline never completes, users see "running" status indefinitely
   - **Recommended Fix:** Deploy Python pipeline separately (AWS Lambda, Cloud Run, or dedicated server)

3. **Missing CSRF Protection** - ⚠️ RECOMMENDED
   - **Issue:** POST `/api/run` accepts requests based only on cookie authentication
   - **Risk:** Cross-site request forgery could trigger unauthorized pipeline executions
   - **Recommended Fix:** Add CSRF token validation (use Next.js middleware)

**Security Strengths:**
- ✅ Input sanitization for `company_id` (regex: `/[^a-z0-9-]/gi`)
- ✅ Path traversal prevention for `runId` (regex validation added)
- ✅ HTTP-only cookies for authentication
- ✅ Proper error messages (no sensitive data leakage)

### Performance Considerations

**Concerns Identified:**

1. **Synchronous Blob Download** - Low Priority
   - Current: Fetches entire PDF before spawning subprocess (~2-5s for large files)
   - Recommendation: Stream directly to subprocess if blob storage supports it

2. **No Concurrency Limits** - Medium Priority
   - Risk: Multiple simultaneous runs could exhaust server resources
   - Recommendation: Implement queue system (Redis) or simple file-based semaphore

3. **Polling Overhead** - Low Priority
   - Frontend expected to poll every 2 seconds per story design
   - Acceptable for MVP, consider WebSockets for v2

**Performance Strengths:**
- ✅ Non-blocking subprocess execution (doesn't block API response)
- ✅ Efficient log parsing (no regex, simple string.includes())
- ✅ Lazy loading of Stage 1 JSON (only when stage >= 1)

### Files Modified During Review

The following files were refactored with security and documentation improvements:

1. `innovation-web/app/api/run/route.ts`
   - Replaced `exec` with `execFile` import
   - Added `run_id` format validation
   - Refactored subprocess execution to use array arguments (prevents injection)

2. `innovation-web/app/api/status/[runId]/route.ts`
   - Added comprehensive JSDoc to `detectStageFromLog()` function
   - Added comprehensive JSDoc to `detectStatusFromLog()` function

**Request to Dev:** Please update the File List section of the story to reflect these modifications.

### Deployment Risk Assessment

**🚨 CRITICAL DEPLOYMENT BLOCKER:**

The current implementation **WILL NOT WORK** on Vercel production due to serverless function lifecycle:

**Problem:**
```typescript
execFile('python', [...], (error, stdout, stderr) => {
  // This callback executes AFTER response is sent
  // Vercel freezes execution at this point
  // Python process is terminated
})

return NextResponse.json({ run_id, status: 'running' }) // Response sent, function frozen
```

**Evidence:**
- Story explicitly targets Vercel deployment (AC notes, architecture docs)
- Vercel serverless functions freeze after response (documented limitation)
- No mechanism to keep function alive during pipeline execution (2-5 minutes)

**Recommended Solutions (choose one):**

1. **Separate Python Service** (Best for production scale)
   - Deploy Python pipeline to AWS Lambda / Google Cloud Run / Railway
   - API routes trigger via HTTP webhook
   - Poll external service for status

2. **Vercel Cron + Queue** (Acceptable for MVP)
   - `/api/run` writes job to queue (Upstash Redis / file-based)
   - Vercel cron job (runs every minute) picks up jobs and executes
   - Status endpoint reads from queue

3. **Change Hosting Platform** (Simplest architecture)
   - Deploy entire app to Railway, Fly.io, or Render
   - Platforms support long-running processes
   - No code changes needed

**Recommendation:** Defer production deployment until architecture decision is made. Current implementation suitable for **local development only**.

### Gate Status

Gate: **CONCERNS** → `docs/qa/gates/3.1-api-routes-pipeline-execution.yml`

**Rationale:** Implementation is functionally correct with good code quality, but has critical architectural incompatibility with stated deployment target (Vercel) and zero automated test coverage. Security vulnerability was fixed during review. Requires architectural decision before production deployment.

### Recommended Status

**⚠️ Changes Required** - Address the following before marking Done:

1. **IMMEDIATE:** Architectural decision on Vercel serverless incompatibility
2. **IMMEDIATE:** Verify Story 3.2 (Python modifications) is complete and tested
3. **IMMEDIATE:** Test backward compatibility (Python CLI `--batch` mode)
4. **HIGH PRIORITY:** Add minimum viable test suite (at least P0 security tests)
5. **MEDIUM PRIORITY:** Resolve data directory duplication issue

**Story owner decides final status after addressing deployment blocker.**

---

**Additional Notes:**

This review uncovered a fundamental architecture mismatch: the story's acceptance criteria assume long-running subprocess execution works on Vercel, but Vercel's serverless architecture freezes functions after response. This wasn't apparent during manual local testing (where it works fine) but will fail in production.

The team should decide:
- Accept limitation and change deployment target (Railway/Fly.io)
- Redesign to use external Python service + webhooks
- Implement queue-based execution with Vercel cron

All three options are viable; recommendation depends on scale requirements and operational preferences.
