# ⚠️ CRITICAL: Clerk User ID Format Issue with PostgreSQL

## Problem Discovered

**Clerk user IDs are NOT standard UUIDs** - they use a prefixed string format like `user_2abcdef123456789` or `org_3xyz987654321abc`.

This causes a **type mismatch error** when using PostgreSQL `uuid` column type with Prisma.

---

## Root Cause

### Clerk ID Format
```
user_2abcdef123456789  ← NOT a valid UUID
org_3xyz987654321abc   ← NOT a valid UUID
```

### Standard UUID Format
```
550e8400-e29b-41d4-a716-446655440000  ← Valid UUID
```

### The Conflict

**Current Prisma Schema (WRONG):**
```prisma
model User {
  id        String   @id @default(uuid())    // ❌ Generates valid UUID
  clerkId   String   @unique                 // ❌ Tries to store "user_2abc..." string
}
```

**PostgreSQL Behavior:**
- `uuid` column type enforces UUID format validation
- Clerk's `"user_"` prefix makes the value invalid for UUID columns
- Prisma throws type mismatch errors on queries/inserts

---

## Solution: Use String/Text Columns for Clerk IDs

### ✅ Corrected Prisma Schema

```prisma
// prisma/schema.prisma

model User {
  id        String   @id @default(uuid())    // ✅ UUID for internal ID
  clerkId   String   @unique                 // ✅ String for "user_2abc..." format
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  runs              Run[]
  opportunityCards  OpportunityCard[]

  @@index([clerkId])
  @@index([email])
}
```

**Key Changes:**
- `clerkId` is stored as `String` (maps to PostgreSQL `TEXT`)
- This accepts Clerk's prefixed format: `user_2abcdef123456789`
- No conversion or prefix stripping needed

---

## Database Column Types

### PostgreSQL Schema (Auto-Generated by Prisma)

```sql
CREATE TABLE "User" (
    id TEXT PRIMARY KEY DEFAULT gen_random_uuid()::text,
    "clerkId" TEXT UNIQUE NOT NULL,           -- ✅ TEXT for "user_..." format
    email TEXT UNIQUE NOT NULL,
    name TEXT,
    "createdAt" TIMESTAMP NOT NULL DEFAULT NOW(),
    "updatedAt" TIMESTAMP NOT NULL
);

CREATE UNIQUE INDEX "User_clerkId_key" ON "User"("clerkId");
CREATE INDEX "User_clerkId_idx" ON "User"("clerkId");
CREATE INDEX "User_email_idx" ON "User"("email");
```

---

## API Route Implementation (No Changes Needed)

```typescript
// app/api/runs/route.ts
import { auth } from '@clerk/nextjs/server'
import { prisma } from '@/lib/prisma'

export async function GET() {
  const { userId } = await auth()  // Returns "user_2abcdef123456789"

  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  // ✅ Works perfectly with String column
  const runs = await prisma.run.findMany({
    where: {
      user: { clerkId: userId }  // "user_2abcdef123456789" matches TEXT column
    }
  })

  return NextResponse.json({ runs })
}
```

**Why This Works:**
- Clerk's `auth()` returns `"user_2abcdef123456789"` as a string
- Prisma queries `clerkId` (TEXT column) with exact match
- No conversion or type casting needed

---

## Backend (asyncpg) Implementation (No Changes Needed)

```python
# backend/app/services/database_service.py

async def create_user(self, clerk_id: str, email: str, name: str):
    """Create user with Clerk ID."""
    pool = await self.get_pool()
    async with pool.acquire() as conn:
        await conn.execute(
            '''
            INSERT INTO "User" (id, "clerkId", email, name, "createdAt", "updatedAt")
            VALUES (gen_random_uuid()::text, $1, $2, $3, NOW(), NOW())
            ON CONFLICT ("clerkId") DO NOTHING
            ''',
            clerk_id,  # "user_2abcdef123456789" as string
            email,
            name
        )
```

**Why This Works:**
- `clerk_id` is passed as plain string (`$1` parameter)
- PostgreSQL TEXT column accepts any string value
- No UUID validation issues

---

## Migration Strategy

### If You Already Have UUID Columns

**Option 1: Recreate Database (Development Only)**

```bash
# WARNING: Deletes all data
npx prisma migrate reset

# Apply new schema with String columns
npx prisma migrate dev --name fix_clerk_id_types
```

**Option 2: Manual Migration (Production)**

```sql
-- Step 1: Add new TEXT column
ALTER TABLE "User" ADD COLUMN "clerkIdNew" TEXT;

-- Step 2: Copy data (strip UUID validation if needed)
UPDATE "User" SET "clerkIdNew" = "clerkId";

-- Step 3: Drop old column
ALTER TABLE "User" DROP COLUMN "clerkId";

-- Step 4: Rename new column
ALTER TABLE "User" RENAME COLUMN "clerkIdNew" TO "clerkId";

-- Step 5: Add constraints
ALTER TABLE "User" ADD CONSTRAINT "User_clerkId_key" UNIQUE ("clerkId");
CREATE INDEX "User_clerkId_idx" ON "User"("clerkId");
```

**Option 3: Prisma Migration (Recommended)**

```bash
# 1. Update prisma/schema.prisma (change clerkId to String)
# 2. Create migration
npx prisma migrate dev --name fix_clerk_uuid_to_string

# Prisma auto-generates:
# - Column type change from UUID to TEXT
# - Data preservation during migration
# - Index recreation
```

---

## Updated Architecture Files

### Files to Update

1. **`docs/architecture/3.5-prisma-database-architecture.md`**
   - Section 3.5.3: Update User model schema
   - Add note about Clerk ID format

2. **`docs/architecture/6.2-prisma-api-routes.md`**
   - Add clarification about Clerk ID being string, not UUID

3. **`docs/architecture/7.2-asyncpg-database-service.md`**
   - Update any references to UUID for user IDs

### Key Schema Changes

**Before (WRONG):**
```prisma
model User {
  id        String   @id @default(uuid())
  clerkId   String   @unique  // ❌ Will fail with "user_..." prefix
}
```

**After (CORRECT):**
```prisma
model User {
  id        String   @id @default(uuid())
  clerkId   String   @unique  // ✅ String/TEXT accepts "user_..." prefix
}
```

---

## Testing After Fix

### 1. Test User Creation

```typescript
// Test in app/api/test-clerk/route.ts
import { auth, currentUser } from '@clerk/nextjs/server'
import { prisma } from '@/lib/prisma'

export async function GET() {
  const { userId } = await auth()
  const clerkUser = await currentUser()

  console.log('Clerk userId:', userId)  // "user_2abcdef123456789"
  console.log('Clerk user email:', clerkUser?.emailAddresses[0]?.emailAddress)

  // Create or find user
  const user = await prisma.user.upsert({
    where: { clerkId: userId },
    update: {},
    create: {
      clerkId: userId,
      email: clerkUser?.emailAddresses[0]?.emailAddress || 'test@example.com',
      name: clerkUser?.firstName || 'Test User'
    }
  })

  return NextResponse.json({ user })
}
```

### 2. Test Run Creation

```typescript
// Test in app/api/runs/route.ts
export async function POST(request: Request) {
  const { userId } = await auth()

  const user = await prisma.user.upsert({
    where: { clerkId: userId },  // ✅ Works with "user_..." string
    update: {},
    create: {
      clerkId: userId,
      email: 'placeholder@example.com'
    }
  })

  const run = await prisma.run.create({
    data: {
      userId: user.id,  // ✅ Links to internal UUID
      companyId: 'lactalis-canada',
      companyName: 'Lactalis',
      documentName: 'test.pdf',
      documentUrl: 'https://example.com/test.pdf'
    }
  })

  return NextResponse.json({ run })
}
```

### 3. Expected Behavior

**✅ Success:**
- Clerk user ID `"user_2abcdef123456789"` stored in TEXT column
- No type mismatch errors
- Queries work with exact string match
- Relations work via internal UUID

**❌ Failure (if not fixed):**
```
Error: Invalid UUID format
Error: Type mismatch for clerkId field
Error: Expected UUID, got string with prefix
```

---

## Summary

### Root Cause
- Clerk user IDs use prefixed format: `user_2abcdef123456789`
- PostgreSQL UUID columns reject non-UUID strings
- Type mismatch between Clerk format and UUID validation

### Solution
- **Use `String` type in Prisma for `clerkId` field**
- Maps to PostgreSQL `TEXT` column
- Accepts Clerk's prefixed string format
- No conversion or stripping needed

### Action Items
- ✅ Update Prisma schema: `clerkId String @unique`
- ✅ Run migration: `npx prisma migrate dev --name fix_clerk_id_types`
- ✅ Test user creation with Clerk authentication
- ✅ Update architecture documentation

---

## References

- **Clerk Documentation:** https://clerk.com/docs/guides/development/integrations/databases/neon
- **PostgreSQL UUID Type:** https://www.postgresql.org/docs/current/datatype-uuid.html
- **Prisma String vs UUID:** https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string

---

## Additional Notes

### Why Not Strip the Prefix?

**❌ Bad Approach:**
```typescript
const clerkIdStripped = userId.replace('user_', '')  // "2abcdef123456789"
// Still not a valid UUID format!
```

**Problem:**
- Even without prefix, `"2abcdef123456789"` is NOT a valid UUID
- Valid UUID: `550e8400-e29b-41d4-a716-446655440000`
- Clerk IDs are NOT UUIDs, they're custom identifiers

**✅ Correct Approach:**
- Store Clerk ID as-is in TEXT column
- Use internal UUID for primary key (`User.id`)
- No conversion needed

### Performance Impact

**TEXT vs UUID:**
- TEXT: 15-26 bytes (Clerk ID length)
- UUID: 16 bytes

**Impact:**
- Minimal storage difference
- TEXT indexing is fast for exact matches
- No performance degradation for queries

**Verdict:** Using TEXT for Clerk IDs is the correct and recommended approach.

---
