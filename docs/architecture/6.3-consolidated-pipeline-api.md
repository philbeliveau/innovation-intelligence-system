# 6.3 Consolidated Pipeline API Routes

**Last Updated:** 2025-10-25
**Status:** ✅ IMPLEMENTED
**Branch:** `architecture-cleanup-prisma`

## Overview

All pipeline-related API routes have been consolidated under the `/api/pipeline/*` namespace to eliminate fragmentation and improve API discoverability.

### Route Consolidation

| Old Route | New Route | Purpose |
|-----------|-----------|---------|
| `POST /api/run` | `POST /api/pipeline/run` | Start new pipeline execution |
| `GET /api/status/:runId` | `GET /api/pipeline/:runId/status` | Get pipeline status from Prisma |
| `GET /api/runs` | `GET /api/pipeline` | List all user's pipeline runs |
| `GET /api/runs/:runId` | `GET /api/pipeline/:runId` | Get run details with cards/reports |
| `POST /api/runs/:runId/rerun` | `POST /api/pipeline/:runId/rerun` | Duplicate and rerun pipeline |
| `POST /api/runs/:runId/complete` | `POST /api/pipeline/:runId/complete` | Webhook: Pipeline completion |
| `DELETE /api/runs/:runId` | `DELETE /api/pipeline/:runId` | Delete pipeline run |
| *(new)* | `POST /api/pipeline/:runId/stage-update` | Webhook: Stage status update |

**Migration Status:** ✅ All frontend components updated to use new routes

## Endpoint Specifications

### `POST /api/pipeline/run`
**Purpose:** Create new pipeline run and trigger backend execution

**Request:**
```json
{
  "blob_url": "https://blob.vercel-storage.com/uploads/doc.pdf",
  "upload_id": "upload-20250125-142030",
  "company_id": "lactalis-canada"
}
```

**Response:**
```json
{
  "run_id": "run-1738335847-5678",
  "status": "PROCESSING",
  "message": "Pipeline execution started"
}
```

**Implementation:**
```typescript
// innovation-web/app/api/pipeline/run/route.ts
export async function POST(request: NextRequest) {
  const { userId } = await auth()
  const { blob_url, upload_id, company_id } = await request.json()

  // 1. Call Railway backend to start pipeline
  const backendResponse = await runPipeline(blob_url, company_id)

  // 2. Create PipelineRun record in Prisma
  await prisma.pipelineRun.create({
    data: {
      id: backendResponse.run_id,
      userId: user.id,
      documentUrl: blob_url,
      companyName: company_name,
      status: 'PROCESSING'
    }
  })

  return NextResponse.json({
    run_id: backendResponse.run_id,
    status: 'PROCESSING'
  })
}
```

---

### `GET /api/pipeline/:runId/status`
**Purpose:** Get real-time pipeline status from Prisma (not Railway backend)

**Response:**
```json
{
  "run_id": "run-1738335847-5678",
  "status": "processing",
  "current_stage": 3,
  "stages": {
    "1": {
      "status": "completed",
      "output": {...},
      "completed_at": "2025-01-25T14:30:00Z"
    },
    "2": {
      "status": "completed",
      "output": {...},
      "completed_at": "2025-01-25T14:35:00Z"
    },
    "3": {
      "status": "processing",
      "output": null,
      "completed_at": null
    },
    "4": { "status": "pending" },
    "5": { "status": "pending" }
  },
  "brand_name": "Lactalis Canada"
}
```

**Key Change:** Now reads from Prisma `stageOutputs` table, NOT Railway `/status/:runId`

**Implementation:**
```typescript
// innovation-web/app/api/pipeline/[runId]/status/route.ts
export async function GET(request: NextRequest, { params }: { params: Promise<{ runId: string }> }) {
  const run = await prisma.pipelineRun.findUnique({
    where: { id: runId },
    include: {
      stageOutputs: {
        orderBy: { stageNumber: 'asc' }
      }
    }
  })

  // Build stages object from stageOutputs
  const stages: Record<string, any> = {}
  for (const stageOutput of run.stageOutputs) {
    stages[stageOutput.stageNumber.toString()] = {
      status: stageOutput.status.toLowerCase(),
      output: JSON.parse(stageOutput.output),
      completed_at: stageOutput.completedAt?.toISOString()
    }
  }

  return NextResponse.json({
    run_id: run.id,
    status: run.status.toLowerCase(),
    current_stage: Math.max(...Object.keys(stages).map(Number)),
    stages,
    brand_name: run.companyName
  })
}
```

---

### `POST /api/pipeline/:runId/stage-update` 🆕
**Purpose:** Webhook endpoint for Python backend to update stage status in Prisma

**Authentication:** `X-Webhook-Secret` header (must match `WEBHOOK_SECRET` env var)

**Request:**
```json
{
  "stageNumber": 2,
  "stageName": "Signal Amplification",
  "status": "COMPLETED",
  "output": "{\"stage2_output\": \"...\"}",
  "completedAt": "2025-01-25T14:35:00Z"
}
```

**Response:**
```json
{
  "success": true,
  "stageOutput": {
    "id": "clxy123abc",
    "runId": "run-1738335847-5678",
    "stageNumber": 2,
    "status": "COMPLETED"
  }
}
```

**Auto-Update Logic:**
- When `stageNumber = 5` and `status = COMPLETED` → Sets `PipelineRun.status = COMPLETED`, `completedAt = now()`
- When any stage `status = FAILED` → Sets `PipelineRun.status = FAILED`, `completedAt = now()`

**Implementation:**
```typescript
// innovation-web/app/api/pipeline/[runId]/stage-update/route.ts
export async function POST(request: NextRequest, { params }: { params: Promise<{ runId: string }> }) {
  // Authenticate webhook
  const webhookSecret = request.headers.get('X-Webhook-Secret')
  if (webhookSecret !== process.env.WEBHOOK_SECRET) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const { stageNumber, stageName, status, output, completedAt } = await request.json()

  // Upsert StageOutput record
  const stageOutput = await prisma.stageOutput.upsert({
    where: {
      runId_stageNumber: { runId, stageNumber }
    },
    update: {
      status: status as RunStatus,
      output: output || '',
      completedAt: completedAt ? new Date(completedAt) : null
    },
    create: {
      runId, stageNumber, stageName,
      status: status as RunStatus,
      output: output || ''
    }
  })

  // Auto-update PipelineRun status
  if (stageNumber === 5 && status === 'COMPLETED') {
    await prisma.pipelineRun.update({
      where: { id: runId },
      data: { status: 'COMPLETED', completedAt: new Date() }
    })
  }

  if (status === 'FAILED') {
    await prisma.pipelineRun.update({
      where: { id: runId },
      data: { status: 'FAILED', completedAt: new Date() }
    })
  }

  return NextResponse.json({ success: true, stageOutput })
}
```

---

### `GET /api/pipeline`
**Purpose:** List all pipeline runs for authenticated user (paginated)

**Query Parameters:**
- `page` (default: 1)
- `pageSize` (default: 20, max: 100)
- `status` (optional): Filter by PROCESSING, COMPLETED, FAILED, CANCELLED

**Response:**
```json
{
  "runs": [
    {
      "id": "run-1738335847-5678",
      "documentName": "sustainable-packaging.pdf",
      "companyName": "Lactalis Canada",
      "status": "COMPLETED",
      "createdAt": "2025-01-25T14:20:00Z",
      "completedAt": "2025-01-25T14:45:00Z",
      "opportunityCount": 5
    }
  ],
  "pagination": {
    "page": 1,
    "pageSize": 20,
    "total": 47,
    "totalPages": 3
  }
}
```

---

### `GET /api/pipeline/:runId`
**Purpose:** Get detailed run information with opportunity cards and reports

**Response:**
```json
{
  "run": {
    "id": "run-1738335847-5678",
    "documentName": "sustainable-packaging.pdf",
    "documentUrl": "https://blob.vercel-storage.com/...",
    "companyName": "Lactalis Canada",
    "status": "COMPLETED",
    "createdAt": "2025-01-25T14:20:00Z",
    "completedAt": "2025-01-25T14:45:00Z",
    "pipelineVersion": "1.0"
  },
  "opportunityCards": [...],
  "inspirationReports": [...],
  "stageOutputs": [...]
}
```

---

### `POST /api/pipeline/:runId/rerun`
**Purpose:** Duplicate existing run and trigger new pipeline execution

**Request:**
```json
{
  "blob_url": "https://blob.vercel-storage.com/uploads/doc.pdf"
}
```

**Response:**
```json
{
  "run_id": "run-1738335999-8901",
  "status": "PROCESSING",
  "message": "Pipeline rerun started"
}
```

---

### `DELETE /api/pipeline/:runId`
**Purpose:** Delete pipeline run and all associated data (soft delete)

**Response:**
```json
{
  "success": true,
  "message": "Pipeline run deleted successfully"
}
```

---

### `POST /api/pipeline/:runId/complete`
**Purpose:** Webhook from Railway backend when pipeline execution finishes

**Authentication:** `X-Webhook-Secret` header

**Request:**
```json
{
  "status": "COMPLETED",
  "completedAt": "2025-01-25T14:45:00Z",
  "duration": 1500000,
  "opportunities": [...],
  "stageOutputs": {
    "stage1": {...},
    "stage2": {...},
    "stage3": {...},
    "stage4": {...},
    "stage5": {...}
  }
}
```

**Implementation:** Creates `OpportunityCard` and `InspirationReport` records in Prisma

---

## Backend Integration

### Python Backend (Railway)

**New File:** `backend/app/prisma_client.py`

```python
class PrismaAPIClient:
    """HTTP client for calling Next.js Prisma API endpoints."""

    def __init__(self):
        self.frontend_url = os.getenv("FRONTEND_WEBHOOK_URL")
        self.webhook_secret = os.getenv("WEBHOOK_SECRET")

    def update_stage_status(
        self,
        run_id: str,
        stage_number: int,
        stage_name: str,
        status: str,
        output: Optional[str] = None
    ) -> bool:
        """Update stage status in Prisma via HTTP API."""
        url = f"{self.frontend_url}/api/pipeline/{run_id}/stage-update"

        payload = {
            "stageNumber": stage_number,
            "stageName": stage_name,
            "status": status,
            "output": output or ""
        }

        response = requests.post(
            url,
            json=payload,
            headers={"X-Webhook-Secret": self.webhook_secret},
            timeout=30
        )

        return response.ok
```

**Usage in Pipeline:**

```python
# backend/app/pipeline_runner.py
from app.prisma_client import PrismaAPIClient

def execute_pipeline_background(run_id, pdf_path, brand_profile):
    prisma_client = PrismaAPIClient()

    # Initialize stages
    prisma_client.initialize_pipeline_stages(run_id)

    # Stage 1
    prisma_client.mark_stage_processing(run_id, 1)
    stage1_result = stage1.run(input_text)
    prisma_client.mark_stage_complete(run_id, 1, stage1_result)

    # ... repeat for stages 2-5
```

---

## Environment Variables

**Frontend (Vercel):**
```env
WEBHOOK_SECRET=your-secret-here-minimum-32-chars
DATABASE_URL=postgresql://...
```

**Backend (Railway):**
```env
FRONTEND_WEBHOOK_URL=https://innovation-web-rho.vercel.app
WEBHOOK_SECRET=your-secret-here-minimum-32-chars
```

**⚠️ Important:** `WEBHOOK_SECRET` must match between frontend and backend

---

## Migration from Old Routes

### Frontend Components Updated:
- ✅ `components/pipeline/PipelineViewer.tsx`
- ✅ `components/RunCard.tsx`
- ✅ `components/LeftSidebar.tsx`
- ✅ `lib/use-runs.ts`
- ✅ `app/analyze/[uploadId]/page.tsx`
- ✅ `app/runs/page.tsx`
- ✅ `app/runs/[runId]/page.tsx`

### Test Files Updated:
- ✅ `__tests__/api/run/security.test.ts`
- ✅ `lib/__tests__/use-runs.test.ts`
- ✅ `components/__tests__/RunCard.test.tsx`
- ✅ `app/runs/[runId]/__tests__/page.test.tsx`

### Backend Updated:
- ✅ `backend/app/pipeline_runner.py` - Now uses PrismaAPIClient
- ✅ `backend/app/prisma_client.py` - New HTTP client
- ⚠️ `backend/app/routes.py` - `/status/:runId` endpoint deprecated (still exists for legacy)

---

## Testing

### Local Development:
```bash
# 1. Start frontend with updated routes
cd innovation-web
npm run dev

# 2. Update backend .env
FRONTEND_WEBHOOK_URL=http://localhost:3000
WEBHOOK_SECRET=dev-secret-123

# 3. Trigger pipeline and monitor logs
```

### Production Verification:
```bash
# Check route consolidation
curl https://innovation-web-rho.vercel.app/api/pipeline

# Verify stage update webhook
curl -X POST \
  https://innovation-web-rho.vercel.app/api/pipeline/test-run/stage-update \
  -H "X-Webhook-Secret: $WEBHOOK_SECRET" \
  -H "Content-Type: application/json" \
  -d '{"stageNumber":1,"stageName":"Test","status":"COMPLETED","output":"{}"}'
```

---

## Benefits of Consolidation

1. **API Discoverability**: All pipeline operations under `/api/pipeline/*`
2. **Consistent Naming**: RESTful resource-based URLs
3. **Reduced Routes**: 8 routes → 6 routes (25% reduction)
4. **Type Safety**: Shared types between routes in single namespace
5. **Better DX**: Easier to find and understand API structure

---

**Last Updated:** 2025-10-25
**Documentation:** See `backend/PRISMA_INTEGRATION.md` for backend migration details
