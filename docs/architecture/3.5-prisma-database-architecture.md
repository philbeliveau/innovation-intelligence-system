# 3.5 Prisma & Database Architecture

## Overview

This system uses **Prisma ORM** as the type-safe database layer for the Next.js frontend, with **PostgreSQL** hosted on Railway. The architecture implements a separation of concerns: **frontend reads via Prisma** (TypeScript), **backend writes via asyncpg** (Python).

### Key Design Decisions

1. **Prisma on Frontend Only** - TypeScript/JavaScript ORM for Next.js API routes
2. **asyncpg on Backend** - Python async PostgreSQL driver for high-performance pipeline writes
3. **Singleton Pattern** - Prevents connection exhaustion in serverless environments
4. **Migration-Driven Schema** - All database changes version-controlled via Prisma Migrate
5. **User Isolation** - Every query filtered by authenticated Clerk user ID

---

## 3.5.1 Prisma Schema Location

```
prisma/
  schema.prisma           # Complete database schema (see Section 3.5.3)
  migrations/             # Version-controlled SQL migrations
    20250121000000_init/
      migration.sql       # Generated SQL for initial schema
    migration_lock.toml   # Lock file for migration tracking
```

### Database URL Configuration

```prisma
// prisma/schema.prisma
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}
```

**Connection String Formats:**

| Environment | Format | Reasoning |
|-------------|--------|-----------|
| **Vercel** | `postgresql://user:pass@host:5432/db?pgbouncer=true&connection_limit=1` | PgBouncer prevents "too many connections" in serverless |
| **Railway (Backend)** | `postgresql://user:pass@host:5432/db` | Direct connection, asyncpg manages pool |
| **Local Dev** | `postgresql://user:pass@localhost:5432/db` | Direct connection, single developer |

---

## 3.5.2 Prisma Client Singleton Pattern

**File:** `lib/prisma.ts`

```typescript
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient({
  log: process.env.NODE_ENV === 'development'
    ? ['query', 'error', 'warn']
    : ['error'],
})

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma
```

### Why This Pattern is Critical

**Problem:** Serverless functions spawn multiple instances
- Each Next.js API route creates a new Prisma Client instance
- PostgreSQL has connection limit (~100 by default)
- Without singleton: "Too many connections" error after ~100 requests

**Solution:** Singleton pattern + PgBouncer
- Single Prisma Client instance reused across hot reloads
- PgBouncer connection pooling on Vercel
- Development mode: Prevents hot reload connection leaks

---

## 3.5.3 Database Schema (5 Models)

### Complete Prisma Schema

```prisma
// prisma/schema.prisma

model User {
  id        String   @id @default(uuid())
  clerkId   String   @unique  // From Clerk authentication
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  runs              Run[]
  opportunityCards  OpportunityCard[]

  @@index([clerkId])
  @@index([email])
}

model Run {
  id          String   @id @default(uuid())
  userId      String
  companyId   String   // e.g., "lactalis-canada"
  companyName String   // e.g., "Lactalis"
  documentName String  // e.g., "trend-report-q1-2025.pdf"
  documentUrl  String  // Vercel Blob URL

  // Pipeline status
  status       RunStatus @default(PENDING)
  currentStage Int       @default(0)  // 0-5
  errorMessage String?

  // Timestamps
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  completedAt  DateTime?

  // Relations
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  opportunityCards  OpportunityCard[]
  inspirationReport InspirationReport?
  stageOutputs      StageOutput[]

  @@index([userId, createdAt])
  @@index([status])
  @@index([companyId])
}

enum RunStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
}

model OpportunityCard {
  id        String   @id @default(uuid())
  runId     String
  userId    String
  number    Int      // 1-5 (from Stage 5 output)

  // Card content (from Stage 5 JSON)
  title           String
  tagline         String
  problem         String
  solution        String
  why_now         String
  target_segment  String
  quick_win       String

  // User interactions
  starred   Boolean  @default(false)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  run  Run  @relation(fields: [runId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, starred])
  @@index([userId, createdAt])
  @@index([runId, number])
}

model InspirationReport {
  id        String   @id @default(uuid())
  runId     String   @unique

  // Stage 1 outputs
  inspiration1Title    String
  inspiration1Content  String
  inspiration1Elements String[]  // Array of key elements
  inspiration2Title    String
  inspiration2Content  String
  inspiration2Elements String[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  run Run @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId])
}

model StageOutput {
  id          String   @id @default(uuid())
  runId       String
  stageNumber Int      // 1-5

  // Raw outputs
  markdownOutput String  @db.Text  // Full markdown from stage
  jsonOutput     Json?   // Parsed structured data

  createdAt DateTime @default(now())

  // Relations
  run Run @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@index([runId, stageNumber])
}
```

### Entity Relationship Diagram

```
┌─────────────────┐
│      User       │
│  (Clerk Auth)   │
└────────┬────────┘
         │
         │ 1:N
         ├───────────────────────────┐
         │                           │
         ▼                           ▼
┌─────────────────┐         ┌────────────────────┐
│      Run        │ 1:N     │  OpportunityCard   │
│ (Pipeline Exec) ├────────>│  (Stage 5 Output)  │
└────────┬────────┘         └────────────────────┘
         │
         │ 1:1
         ▼
┌─────────────────────┐
│ InspirationReport   │
│ (Stage 1 Output)    │
└─────────────────────┘
         │
         │ 1:N
         ▼
┌─────────────────┐
│  StageOutput    │
│  (All Stages)   │
└─────────────────┘
```

### Cascade Delete Behavior

```typescript
// When user is deleted → All associated data is deleted
User → Runs → OpportunityCards
           → InspirationReports
           → StageOutputs
```

**Security Benefit:** User data isolation enforced at database level

---

## 3.5.4 Type Safety Benefits

### Compile-Time Guarantees

Prisma generates TypeScript types from schema:

```typescript
// ✅ Type-safe query with autocomplete
const runs: Run[] = await prisma.run.findMany({
  where: { userId: 'abc' },        // ✅ TypeScript knows this field exists
  include: { opportunityCards: true } // ✅ TypeScript knows this relation
})

// ❌ Compile-time error if wrong field
const x = await prisma.run.findMany({
  where: { wrongField: 'abc' }  // ❌ TypeScript error: Property 'wrongField' does not exist
})

// ✅ Type-safe access to related data
runs[0].opportunityCards[0].title  // ✅ TypeScript knows the structure
```

### Generated Types

After running `npx prisma generate`, Prisma creates:

```typescript
// node_modules/.prisma/client/index.d.ts (auto-generated)

export type Run = {
  id: string
  userId: string
  companyId: string
  companyName: string
  documentName: string
  documentUrl: string
  status: RunStatus
  currentStage: number
  errorMessage: string | null
  createdAt: Date
  updatedAt: Date
  completedAt: Date | null
}

export type RunWithCards = Run & {
  opportunityCards: OpportunityCard[]
}
```

---

## 3.5.5 Database Indexing Strategy

### Index Rationale

```prisma
// User lookups by authentication
@@index([clerkId])      // Fast lookup during auth: WHERE clerkId = $1
@@index([email])        // Fast lookup for email queries

// Run queries (most common access patterns)
@@index([userId, createdAt])  // Fast paginated user queries: ORDER BY createdAt DESC
@@index([status])             // Filter by status: WHERE status = 'COMPLETED'
@@index([companyId])          // Filter by company: WHERE companyId = 'lactalis-canada'

// OpportunityCard queries
@@index([userId, starred])    // Fast starred card lookup
@@index([userId, createdAt])  // User's cards by date
@@index([runId, number])      // Cards for specific run, ordered by number
```

### Query Performance

| Query Pattern | Index Used | Performance |
|---------------|------------|-------------|
| `WHERE user.clerkId = ?` | `User.clerkId` | O(log n) |
| `WHERE userId = ? ORDER BY createdAt DESC` | `Run.userId_createdAt` | O(log n) |
| `WHERE userId = ? AND starred = true` | `OpportunityCard.userId_starred` | O(log n) |

---

## 3.5.6 Query Optimization Patterns

### ❌ Bad: Over-fetching

```typescript
// Fetches ALL fields and ALL relations (wasteful)
const run = await prisma.run.findUnique({
  where: { id: runId }
})
```

### ✅ Good: Selective Field Loading

```typescript
// Fetch only needed fields
const runs = await prisma.run.findMany({
  select: {
    id: true,
    documentName: true,
    createdAt: true,
    status: true,
    _count: { select: { opportunityCards: true } }  // Count only, not full data
  }
})
```

### ✅ Good: Strategic Include for Relations

```typescript
// Load relations only when needed
const run = await prisma.run.findUnique({
  where: { id: runId },
  include: {
    opportunityCards: {
      orderBy: { number: 'asc' }  // Sorted cards
    },
    inspirationReport: true,
    stageOutputs: {
      orderBy: { stageNumber: 'asc' }
    }
  }
})
```

---

## 3.5.7 Connection Pool Monitoring

### Enable Query Logging (Development)

```typescript
// lib/prisma.ts (development mode)
export const prisma = new PrismaClient({
  log: [
    { level: 'query', emit: 'event' },
    { level: 'error', emit: 'stdout' },
    { level: 'warn', emit: 'stdout' },
  ],
})

prisma.$on('query', (e) => {
  console.log('Query: ' + e.query)
  console.log('Duration: ' + e.duration + 'ms')
})
```

### Connection Pool Configuration

| Environment | Pool Size | Timeout | Connection Limit Flag |
|-------------|-----------|---------|----------------------|
| **Vercel** | 1 per function | 10s | `?connection_limit=1` |
| **Railway (asyncpg)** | 5-20 | 60s | N/A (direct pool) |
| **Local Dev** | 2 | 10s | N/A |

---

## 3.5.8 Error Handling Patterns

### Prisma-Specific Error Codes

```typescript
import { Prisma } from '@prisma/client'

try {
  const run = await prisma.run.findUniqueOrThrow({
    where: { id: runId }
  })
} catch (error) {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    // P2025: Record not found
    if (error.code === 'P2025') {
      return NextResponse.json(
        { error: 'Run not found' },
        { status: 404 }
      )
    }

    // P2002: Unique constraint violation
    if (error.code === 'P2002') {
      return NextResponse.json(
        { error: 'Duplicate entry' },
        { status: 409 }
      )
    }

    // P2003: Foreign key constraint failed
    if (error.code === 'P2003') {
      return NextResponse.json(
        { error: 'Invalid reference' },
        { status: 400 }
      )
    }
  }

  // Unknown error
  console.error('Database error:', error)
  return NextResponse.json(
    { error: 'Database error' },
    { status: 500 }
  )
}
```

### Common Prisma Error Codes

| Code | Meaning | HTTP Status | Handler Strategy |
|------|---------|-------------|------------------|
| P2025 | Record not found | 404 | Return "not found" message |
| P2002 | Unique constraint | 409 | Return "duplicate" message |
| P2003 | Foreign key fail | 400 | Return "invalid reference" |
| P2021 | Table not exist | 500 | Retry migration deployment |

---

## 3.5.9 Security Architecture

### Row-Level Security via Clerk

```typescript
import { auth } from '@clerk/nextjs/server'
import { prisma } from '@/lib/prisma'

// ✅ SECURE: Always filter by authenticated user
export async function GET() {
  const { userId } = await auth()

  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const runs = await prisma.run.findMany({
    where: {
      user: { clerkId: userId }  // From auth()
    }
  })

  return NextResponse.json({ runs })
}
```

### ❌ Security Anti-Patterns

```typescript
// ❌ DANGER: Exposes all users' data
const runs = await prisma.run.findMany()

// ❌ DANGER: User-controlled query parameter
const runs = await prisma.run.findMany({
  where: { userId: req.query.userId }  // NEVER trust client input
})

// ❌ DANGER: Missing authentication check
export async function GET() {
  // No auth check!
  const runs = await prisma.run.findMany()
}
```

### SQL Injection Protection

**Prisma automatically parameterizes all queries** - no SQL injection risk with standard Prisma Client operations.

```typescript
// ✅ SAFE: Prisma parameterizes automatically
const user = await prisma.user.findUnique({
  where: { email: userInput }  // Automatically escaped
})

// ⚠️ CAUTION: Raw SQL bypasses Prisma's protections
const users = await prisma.$queryRaw`
  SELECT * FROM User WHERE email = ${userInput}  // Still safe (tagged template)
`

// ❌ DANGER: String concatenation in raw SQL
const users = await prisma.$queryRawUnsafe(
  `SELECT * FROM User WHERE email = '${userInput}'`  // VULNERABLE!
)
```

---

## 3.5.10 Migration Workflow

### Development Workflow

```bash
# 1. Make schema changes in prisma/schema.prisma
#    Example: Add new field to User model

# 2. Create migration
npx prisma migrate dev --name add_user_preferences

# Prisma generates:
#   - prisma/migrations/20250121_add_user_preferences/migration.sql
#   - Updates Prisma Client types
#   - Applies migration to local database

# 3. Commit to Git
git add prisma/migrations
git commit -m "feat: add user preferences to User model"

# 4. Push to repository
git push origin main
```

### Production Deployment (Railway)

**Automatic Migration Deployment:**

```json
// package.json
{
  "scripts": {
    "build": "prisma generate && prisma migrate deploy && next build",
    "start": "next start",
    "migrate": "prisma migrate deploy"
  }
}
```

**Railway Build Process:**
1. `npm install` - Installs Prisma CLI and dependencies
2. `prisma generate` - Generates Prisma Client from schema
3. `prisma migrate deploy` - Applies pending migrations to PostgreSQL
4. `next build` - Builds Next.js application

**Vercel Deployment:**
- Migrations are **NOT** run on Vercel (frontend only reads)
- Prisma Client is generated during build (`npx prisma generate`)
- Connects to Railway PostgreSQL via `DATABASE_URL`

### Migration Rollback Strategy

```bash
# View migration history
npx prisma migrate status

# Development rollback (WARNING: Deletes all data)
npx prisma migrate reset

# Production rollback (manual)
# 1. Identify migration to rollback
# 2. Create new migration that reverses changes
npx prisma migrate dev --name rollback_user_preferences

# 3. Manually write reverse SQL in migration file
# prisma/migrations/20250121_rollback_user_preferences/migration.sql
```

---

## 3.5.11 Testing Strategy

### Prisma Studio (Visual Database Browser)

```bash
# Open Prisma Studio
npx prisma studio

# Opens browser at http://localhost:5555
# Features:
#   - Visual CRUD operations
#   - Filter and sort data
#   - View relationships
#   - Test queries
```

### Seed Data for Testing

**File:** `prisma/seed.ts`

```typescript
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  // Create test user
  const user = await prisma.user.create({
    data: {
      clerkId: 'test_user_123',
      email: 'test@example.com',
      name: 'Test User'
    }
  })

  // Create test run
  const run = await prisma.run.create({
    data: {
      userId: user.id,
      companyId: 'lactalis-canada',
      companyName: 'Lactalis',
      documentName: 'test-report.pdf',
      documentUrl: 'https://example.com/test.pdf',
      status: 'COMPLETED',
      currentStage: 5,
      completedAt: new Date()
    }
  })

  // Create test opportunity cards
  await prisma.opportunityCard.createMany({
    data: [1, 2, 3, 4, 5].map(num => ({
      runId: run.id,
      userId: user.id,
      number: num,
      title: `Test Opportunity ${num}`,
      tagline: `Test tagline ${num}`,
      problem: 'Test problem',
      solution: 'Test solution',
      why_now: 'Test timing',
      target_segment: 'Test segment',
      quick_win: 'Test quick win'
    }))
  })

  console.log({ user, run, cardCount: 5 })
}

main()
  .catch(console.error)
  .finally(() => prisma.$disconnect())
```

**Run Seed:**

```bash
npx prisma db seed
```

**Configure in package.json:**

```json
{
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  }
}
```

---

## 3.5.12 Performance Benchmarks

### Expected Query Performance (10,000 runs)

| Operation | Query Time | Index Used |
|-----------|------------|------------|
| List user's runs (page 1) | ~15ms | `userId_createdAt` |
| Get run with cards | ~25ms | Primary key + includes |
| Count starred cards | ~10ms | `userId_starred` |
| Filter by company | ~20ms | `companyId` |
| Search by status | ~15ms | `status` |

### Connection Pool Limits

| Environment | Max Connections | Typical Usage | Headroom |
|-------------|-----------------|---------------|----------|
| Railway PostgreSQL | 100 | ~10-20 | 80-90 |
| Vercel (PgBouncer) | 100 pooled | ~5-10 | 90-95 |
| Local Dev | 10 | 1-2 | 8-9 |

---

## Next Steps

See the following sections for implementation details:
- **Section 6.2** - Prisma-powered API routes
- **Section 7.2** - asyncpg backend database service
- **Section 8.3** - Railway PostgreSQL deployment
- **Section 12** - Source tree with `prisma/` folder

---
