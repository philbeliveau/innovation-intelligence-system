# 6.2 Prisma-Powered API Routes

## Overview

All user-facing API routes use **Prisma Client** for type-safe database queries. Every route enforces authentication via Clerk and filters data by the authenticated user's ID.

---

## 6.2.1 GET /api/runs - List User Runs

### Purpose
Fetch paginated list of user's pipeline runs with filtering and sorting.

### Request

```typescript
GET /api/runs?page=1&pageSize=12&companyId=lactalis-canada&status=COMPLETED
```

**Query Parameters:**
| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `page` | number | No | Page number (default: 1) |
| `pageSize` | number | No | Items per page (default: 12, max: 50) |
| `companyId` | string | No | Filter by company ID |
| `status` | string | No | Filter by status: PENDING, RUNNING, COMPLETED, FAILED |

### Response

```typescript
{
  runs: [
    {
      id: "550e8400-e29b-41d4-a716-446655440000",
      companyId: "lactalis-canada",
      companyName: "Lactalis",
      documentName: "trend-report-q1-2025.pdf",
      status: "COMPLETED",
      currentStage: 5,
      createdAt: "2025-01-21T10:30:00Z",
      completedAt: "2025-01-21T11:15:00Z",
      _count: {
        opportunityCards: 5
      }
    },
    // ... more runs
  ],
  pagination: {
    page: 1,
    pageSize: 12,
    totalCount: 45,
    totalPages: 4
  }
}
```

### Implementation

```typescript
// app/api/runs/route.ts
import { NextResponse } from 'next/server'
import { auth } from '@clerk/nextjs/server'
import { prisma } from '@/lib/prisma'

export async function GET(request: Request) {
  // 1. Authenticate user
  const { userId } = await auth()

  if (!userId) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    )
  }

  // 2. Parse query parameters
  const { searchParams } = new URL(request.url)
  const page = Number(searchParams.get('page')) || 1
  const pageSize = Math.min(Number(searchParams.get('pageSize')) || 12, 50)
  const companyId = searchParams.get('companyId') || undefined
  const status = searchParams.get('status') as RunStatus | undefined

  // 3. Build where clause
  const where = {
    user: { clerkId: userId },
    ...(companyId && { companyId }),
    ...(status && { status })
  }

  // 4. Execute transaction for count + data
  const [runs, totalCount] = await prisma.$transaction([
    prisma.run.findMany({
      where,
      include: {
        _count: { select: { opportunityCards: true } }
      },
      orderBy: { createdAt: 'desc' },
      skip: (page - 1) * pageSize,
      take: pageSize
    }),
    prisma.run.count({ where })
  ])

  // 5. Return paginated response
  return NextResponse.json({
    runs,
    pagination: {
      page,
      pageSize,
      totalCount,
      totalPages: Math.ceil(totalCount / pageSize)
    }
  })
}
```

### Security Features

✅ **Authentication Check**: Rejects unauthenticated requests
✅ **User Isolation**: Filters by `user.clerkId` from Clerk session
✅ **Page Size Limit**: Caps at 50 items to prevent abuse
✅ **Type Safety**: TypeScript enforces correct field names

---

## 6.2.2 GET /api/runs/[runId] - Get Run Details

### Purpose
Fetch complete run with all related data: cards, report, stage outputs.

### Request

```typescript
GET /api/runs/550e8400-e29b-41d4-a716-446655440000
```

### Response

```typescript
{
  run: {
    id: "550e8400-e29b-41d4-a716-446655440000",
    companyId: "lactalis-canada",
    companyName: "Lactalis",
    documentName: "trend-report-q1-2025.pdf",
    documentUrl: "https://blob.vercel-storage.com/...",
    status: "COMPLETED",
    currentStage: 5,
    createdAt: "2025-01-21T10:30:00Z",
    completedAt: "2025-01-21T11:15:00Z",

    opportunityCards: [
      {
        id: "card-uuid-1",
        number: 1,
        title: "Protein-Enriched Cheese Snacks",
        tagline: "14g protein in every bite-sized pack",
        problem: "Parents want high-protein snacks kids actually like",
        solution: "String cheese infused with whey protein isolate",
        why_now: "High-protein trend expanding from fitness to family",
        target_segment: "Health-conscious parents with kids 6-12",
        quick_win: "Reformulate existing string cheese SKU",
        starred: false
      },
      // ... cards 2-5
    ],

    inspirationReport: {
      inspiration1Title: "Athletic Recovery Goes Mainstream",
      inspiration1Content: "Sports nutrition brands are...",
      inspiration1Elements: ["Protein positioning", "Kid-friendly formats"],
      inspiration2Title: "Snackification of Meals",
      inspiration2Content: "Consumers are replacing...",
      inspiration2Elements: ["Grab-and-go", "Portion control"]
    },

    stageOutputs: [
      {
        stageNumber: 1,
        markdownOutput: "## Track 1: Athletic Recovery...",
        jsonOutput: { /* parsed data */ }
      },
      // ... stages 2-5
    ]
  }
}
```

### Implementation

```typescript
// app/api/runs/[runId]/route.ts
import { NextResponse } from 'next/server'
import { auth } from '@clerk/nextjs/server'
import { prisma } from '@/lib/prisma'
import { Prisma } from '@prisma/client'

export async function GET(
  request: Request,
  { params }: { params: { runId: string } }
) {
  // 1. Authenticate user
  const { userId } = await auth()

  if (!userId) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    )
  }

  // 2. Fetch run with all relations
  try {
    const run = await prisma.run.findFirst({
      where: {
        id: params.runId,
        user: { clerkId: userId }  // Security: Only user's own runs
      },
      include: {
        opportunityCards: {
          orderBy: { number: 'asc' }
        },
        inspirationReport: true,
        stageOutputs: {
          orderBy: { stageNumber: 'asc' }
        }
      }
    })

    // 3. Handle not found
    if (!run) {
      return NextResponse.json(
        { error: 'Run not found' },
        { status: 404 }
      )
    }

    // 4. Return run with all related data
    return NextResponse.json({ run })

  } catch (error) {
    // 5. Handle database errors
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      return NextResponse.json(
        { error: 'Database error' },
        { status: 500 }
      )
    }
    throw error
  }
}
```

### Security Features

✅ **Ownership Verification**: `WHERE user.clerkId = userId`
✅ **404 for Unauthorized**: Returns "not found" even if run exists (prevents ID enumeration)
✅ **Relation Loading**: Uses `include` for type-safe joins

---

## 6.2.3 POST /api/runs - Create New Run

### Purpose
Create new run record and trigger Railway backend pipeline.

### Request

```typescript
POST /api/runs
Content-Type: application/json

{
  companyId: "lactalis-canada",
  companyName: "Lactalis",
  documentName: "trend-report-q1-2025.pdf",
  documentUrl: "https://blob.vercel-storage.com/abc123.pdf"
}
```

### Response

```typescript
{
  runId: "550e8400-e29b-41d4-a716-446655440000"
}
```

### Implementation

```typescript
// app/api/runs/route.ts
export async function POST(request: Request) {
  // 1. Authenticate user
  const { userId } = await auth()

  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  // 2. Parse request body
  const body = await request.json()
  const { companyId, companyName, documentName, documentUrl } = body

  // 3. Get or create user in database
  const user = await prisma.user.upsert({
    where: { clerkId: userId },
    update: {},
    create: {
      clerkId: userId,
      email: 'placeholder@example.com',  // TODO: Get from Clerk
      name: 'User'
    }
  })

  // 4. Create run record
  const run = await prisma.run.create({
    data: {
      userId: user.id,
      companyId,
      companyName,
      documentName,
      documentUrl,
      status: 'PENDING',
      currentStage: 0
    }
  })

  // 5. Trigger Railway backend
  try {
    const backendUrl = process.env.NEXT_PUBLIC_BACKEND_URL
    const response = await fetch(`${backendUrl}/run`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        run_id: run.id,
        blob_url: documentUrl,
        company_id: companyId,
        user_id: user.id
      })
    })

    if (!response.ok) {
      // Mark run as FAILED if backend trigger fails
      await prisma.run.update({
        where: { id: run.id },
        data: {
          status: 'FAILED',
          errorMessage: 'Failed to trigger pipeline'
        }
      })

      return NextResponse.json(
        { error: 'Pipeline trigger failed' },
        { status: 500 }
      )
    }

    // 6. Return run ID for client to poll
    return NextResponse.json({ runId: run.id })

  } catch (error) {
    // Mark run as FAILED on network error
    await prisma.run.update({
      where: { id: run.id },
      data: {
        status: 'FAILED',
        errorMessage: error instanceof Error ? error.message : 'Unknown error'
      }
    })

    throw error
  }
}
```

### Workflow Steps

1. **Authenticate** - Verify Clerk session
2. **Upsert User** - Create user record if first run
3. **Create Run** - Insert run with `PENDING` status
4. **Trigger Backend** - POST to Railway `/run` endpoint
5. **Handle Failure** - Mark run as `FAILED` if trigger fails
6. **Return Run ID** - Client polls `/api/status/:runId`

---

## 6.2.4 POST /api/runs/[runId]/rerun - Rerun Pipeline

### Purpose
Create duplicate run with same parameters and trigger pipeline again.

### Request

```typescript
POST /api/runs/550e8400-e29b-41d4-a716-446655440000/rerun
```

### Response

```typescript
{
  runId: "new-uuid-here"
}
```

### Implementation

```typescript
// app/api/runs/[runId]/rerun/route.ts
export async function POST(
  request: Request,
  { params }: { params: { runId: string } }
) {
  const { userId } = await auth()

  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  // 1. Fetch original run
  const originalRun = await prisma.run.findFirst({
    where: {
      id: params.runId,
      user: { clerkId: userId }
    }
  })

  if (!originalRun) {
    return NextResponse.json({ error: 'Run not found' }, { status: 404 })
  }

  // 2. Create new run with same parameters
  const newRun = await prisma.run.create({
    data: {
      userId: originalRun.userId,
      companyId: originalRun.companyId,
      companyName: originalRun.companyName,
      documentName: `${originalRun.documentName} (rerun)`,
      documentUrl: originalRun.documentUrl,
      status: 'PENDING',
      currentStage: 0
    }
  })

  // 3. Trigger backend (same as POST /api/runs)
  const backendUrl = process.env.NEXT_PUBLIC_BACKEND_URL
  const response = await fetch(`${backendUrl}/run`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      run_id: newRun.id,
      blob_url: originalRun.documentUrl,
      company_id: originalRun.companyId,
      user_id: originalRun.userId
    })
  })

  if (!response.ok) {
    await prisma.run.update({
      where: { id: newRun.id },
      data: { status: 'FAILED', errorMessage: 'Failed to trigger pipeline' }
    })
    return NextResponse.json({ error: 'Pipeline trigger failed' }, { status: 500 })
  }

  return NextResponse.json({ runId: newRun.id })
}
```

---

## 6.2.5 DELETE /api/runs/[runId] - Delete Run

### Purpose
Delete run and all associated data (cascade deletes cards, report, stage outputs).

### Request

```typescript
DELETE /api/runs/550e8400-e29b-41d4-a716-446655440000
```

### Response

```typescript
{
  success: true
}
```

### Implementation

```typescript
// app/api/runs/[runId]/route.ts
export async function DELETE(
  request: Request,
  { params }: { params: { runId: string } }
) {
  const { userId } = await auth()

  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  // 1. Delete run (cascade deletes relations)
  const deletedRun = await prisma.run.deleteMany({
    where: {
      id: params.runId,
      user: { clerkId: userId }  // Security: Only user's own runs
    }
  })

  // 2. Check if run was found
  if (deletedRun.count === 0) {
    return NextResponse.json({ error: 'Run not found' }, { status: 404 })
  }

  // 3. Return success
  return NextResponse.json({ success: true })
}
```

### Cascade Delete Behavior

```prisma
// prisma/schema.prisma
model Run {
  opportunityCards  OpportunityCard[]  @relation(onDelete: Cascade)
  inspirationReport InspirationReport? @relation(onDelete: Cascade)
  stageOutputs      StageOutput[]      @relation(onDelete: Cascade)
}
```

When run is deleted:
1. All `OpportunityCard` records deleted
2. `InspirationReport` record deleted
3. All `StageOutput` records deleted
4. Run record deleted

**Atomic Transaction:** All deletes succeed or all fail (ACID guarantee)

---

## 6.2.6 POST /api/cards/[cardId]/star - Toggle Favorite

### Purpose
Star/unstar an opportunity card.

### Request

```typescript
POST /api/cards/card-uuid-here/star
```

### Response

```typescript
{
  starred: true
}
```

### Implementation

```typescript
// app/api/cards/[cardId]/star/route.ts
export async function POST(
  request: Request,
  { params }: { params: { cardId: string } }
) {
  const { userId } = await auth()

  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  // 1. Fetch card to verify ownership
  const card = await prisma.opportunityCard.findFirst({
    where: {
      id: params.cardId,
      user: { clerkId: userId }
    }
  })

  if (!card) {
    return NextResponse.json({ error: 'Card not found' }, { status: 404 })
  }

  // 2. Toggle starred field
  const updatedCard = await prisma.opportunityCard.update({
    where: { id: params.cardId },
    data: { starred: !card.starred }
  })

  // 3. Return new state
  return NextResponse.json({ starred: updatedCard.starred })
}
```

---

## 6.2.9 Error Handling Patterns

### Prisma Error Codes

```typescript
import { Prisma } from '@prisma/client'

try {
  const run = await prisma.run.findUniqueOrThrow({
    where: { id: runId }
  })
} catch (error) {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case 'P2025':  // Record not found
        return NextResponse.json({ error: 'Run not found' }, { status: 404 })

      case 'P2002':  // Unique constraint violation
        return NextResponse.json({ error: 'Duplicate entry' }, { status: 409 })

      case 'P2003':  // Foreign key constraint failed
        return NextResponse.json({ error: 'Invalid reference' }, { status: 400 })

      default:
        console.error('Database error:', error.code, error.message)
        return NextResponse.json({ error: 'Database error' }, { status: 500 })
    }
  }

  // Unknown error
  console.error('Unexpected error:', error)
  return NextResponse.json({ error: 'Internal server error' }, { status: 500 })
}
```

### Authentication Error Handling

```typescript
const { userId } = await auth()

if (!userId) {
  return NextResponse.json(
    { error: 'Unauthorized' },
    { status: 401 }
  )
}
```

### Validation Error Handling

```typescript
const body = await request.json()

if (!body.companyId || !body.documentUrl) {
  return NextResponse.json(
    { error: 'Missing required fields' },
    { status: 400 }
  )
}
```

---

## 6.2.10 Type Safety Examples

### ✅ Type-Safe Query

```typescript
// TypeScript knows all fields and relations
const run: Run & { opportunityCards: OpportunityCard[] } =
  await prisma.run.findUnique({
    where: { id: runId },
    include: { opportunityCards: true }
  })

// Autocomplete works
run.opportunityCards[0].title  // ✅
```

### ❌ Compile-Time Error

```typescript
const run = await prisma.run.findUnique({
  where: { wrongField: 'abc' }  // ❌ TypeScript error
})
```

### Type-Safe Filtering

```typescript
const where: Prisma.RunWhereInput = {
  user: { clerkId: userId },
  status: 'COMPLETED',  // ✅ Type-checked against RunStatus enum
  companyId: companyIdFilter
}

const runs = await prisma.run.findMany({ where })
```

---

## 6.2.7 POST /api/upload - Upload Document

### Purpose
Upload file to Vercel Blob storage and save document metadata to database.

### Request

```typescript
POST /api/upload
Content-Type: multipart/form-data

file: <PDF, TXT, or MD file>
```

### Response

```typescript
{
  blob_url: "https://blob.vercel-storage.com/abc123.pdf",
  upload_id: "550e8400-e29b-41d4-a716-446655440000"
}
```

### Implementation

```typescript
// app/api/upload/route.ts
import { put } from '@vercel/blob'
import { NextResponse } from 'next/server'
import { auth } from '@clerk/nextjs/server'
import { prisma } from '@/lib/prisma'

export async function POST(request: Request) {
  // 1. Authenticate user
  const { userId: clerkUserId } = await auth()

  if (!clerkUserId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  // 2. Parse multipart form data
  const formData = await request.formData()
  const file = formData.get('file') as File

  if (!file) {
    return NextResponse.json({ error: 'No file provided' }, { status: 400 })
  }

  // 3. Validate file type
  const allowedTypes = ['application/pdf', 'text/plain', 'text/markdown']
  if (!allowedTypes.includes(file.type)) {
    return NextResponse.json({ error: 'Invalid file type' }, { status: 400 })
  }

  // 4. Validate file size (25MB max)
  const maxSize = 25 * 1024 * 1024
  if (file.size > maxSize) {
    return NextResponse.json({ error: 'File too large' }, { status: 400 })
  }

  // 5. Upload to Vercel Blob
  const blob = await put(file.name, file, {
    access: 'public',
    addRandomSuffix: true
  })

  // 6. Upsert user in database
  const user = await prisma.user.upsert({
    where: { clerkId: clerkUserId },
    update: {},
    create: {
      clerkId: clerkUserId,
      email: 'placeholder@example.com',  // TODO: Get from Clerk
      name: 'User'
    }
  })

  // 7. Save document metadata to database
  const document = await prisma.document.create({
    data: {
      userId: user.id,
      fileName: file.name,
      fileSize: file.size,
      blobUrl: blob.url,
      uploadedAt: new Date()
    }
  })

  // 8. Return blob URL and document ID
  return NextResponse.json({
    blob_url: blob.url,
    upload_id: document.id
  })
}
```

### Workflow Steps

1. **Authenticate** - Verify Clerk session
2. **Parse File** - Extract file from multipart form data
3. **Validate** - Check file type and size
4. **Upload to Blob** - Store file in Vercel Blob storage
5. **Upsert User** - Create user record if first upload
6. **Save Metadata** - Create `Document` record in PostgreSQL
7. **Return URL** - Client uses `blob_url` for pipeline trigger

### Security Features

✅ **Authentication Required** - Rejects unauthenticated requests
✅ **File Type Validation** - Only PDF, TXT, MD allowed
✅ **File Size Limit** - 25MB maximum
✅ **User Association** - Document linked to authenticated user
✅ **Public Access** - Blob URL is public (required for Railway backend access)

### Error Handling

```typescript
// File type validation
if (!allowedTypes.includes(file.type)) {
  return NextResponse.json({ error: 'Invalid file type' }, { status: 400 })
}

// File size validation
if (file.size > maxSize) {
  return NextResponse.json({ error: 'File too large' }, { status: 400 })
}

// Blob upload error
try {
  const blob = await put(file.name, file, { access: 'public' })
} catch (error) {
  console.error('Blob upload failed:', error)
  return NextResponse.json({ error: 'Upload failed' }, { status: 500 })
}
```

---

## 6.2.8 GET /api/documents - List User Documents

### Purpose
Fetch user's upload history with pagination.

### Request

```typescript
GET /api/documents?page=1&pageSize=20
```

### Response

```typescript
{
  documents: [
    {
      id: "550e8400-e29b-41d4-a716-446655440000",
      fileName: "trend-report-q1-2025.pdf",
      fileSize: 2457600,  // bytes
      blobUrl: "https://blob.vercel-storage.com/abc123.pdf",
      uploadedAt: "2025-01-21T10:30:00Z",
      createdAt: "2025-01-21T10:30:00Z"
    },
    // ... more documents
  ],
  pagination: {
    page: 1,
    pageSize: 20,
    totalCount: 45,
    totalPages: 3
  }
}
```

### Implementation

```typescript
// app/api/documents/route.ts
export async function GET(request: Request) {
  const { userId } = await auth()

  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  }

  const { searchParams } = new URL(request.url)
  const page = Number(searchParams.get('page')) || 1
  const pageSize = Math.min(Number(searchParams.get('pageSize')) || 20, 50)

  const where = {
    user: { clerkId: userId }
  }

  const [documents, totalCount] = await prisma.$transaction([
    prisma.document.findMany({
      where,
      orderBy: { uploadedAt: 'desc' },
      skip: (page - 1) * pageSize,
      take: pageSize
    }),
    prisma.document.count({ where })
  ])

  return NextResponse.json({
    documents,
    pagination: {
      page,
      pageSize,
      totalCount,
      totalPages: Math.ceil(totalCount / pageSize)
    }
  })
}
```

---

## Summary Table

| Endpoint | Method | Purpose | Prisma Operation |
|----------|--------|---------|------------------|
| `/api/runs` | GET | List user runs | `findMany` + `count` (transaction) |
| `/api/runs/:id` | GET | Get run details | `findFirst` + `include` |
| `/api/runs` | POST | Create run | `create` + backend trigger |
| `/api/runs/:id/rerun` | POST | Duplicate & rerun | `create` (copy params) |
| `/api/runs/:id` | DELETE | Delete run | `deleteMany` (cascade) |
| `/api/cards/:id/star` | POST | Toggle favorite | `update` (toggle field) |
| `/api/upload` | POST | Upload file + save metadata | `upsert` (user) + `create` (document) |
| `/api/documents` | GET | List user documents | `findMany` + `count` (transaction) |

**Key Patterns:**
- ✅ Always authenticate with Clerk
- ✅ Always filter by `user.clerkId`
- ✅ Use transactions for count + data queries
- ✅ Handle Prisma error codes properly
- ✅ Leverage TypeScript types from Prisma
- ✅ Upsert user on first upload/run creation
- ✅ Validate file types and sizes before upload

---
