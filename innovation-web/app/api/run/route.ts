import { NextRequest, NextResponse } from 'next/server'
import { cookies } from 'next/headers'
import { execFile } from 'child_process'
import { writeFileSync } from 'fs'
import { join } from 'path'

export async function POST(request: NextRequest) {
  try {
    // Parse request body
    const body = await request.json()
    const { blob_url, upload_id } = body

    // Validate required fields
    if (!blob_url || !upload_id) {
      return NextResponse.json(
        { error: 'Missing required fields: blob_url and upload_id' },
        { status: 400 }
      )
    }

    // Read company ID from cookie
    const cookieStore = await cookies()
    const companyId = cookieStore.get('company_id')?.value

    if (!companyId) {
      return NextResponse.json(
        { error: 'No company selected. Please complete onboarding first.' },
        { status: 401 }
      )
    }

    // Sanitize company_id to prevent command injection
    const sanitizedCompanyId = companyId.replace(/[^a-z0-9-]/gi, '')
    if (sanitizedCompanyId !== companyId) {
      return NextResponse.json(
        { error: 'Invalid company identifier' },
        { status: 400 }
      )
    }

    // Generate unique run_id
    const run_id = `run-${Date.now()}`

    // Validate run_id format (defense in depth - generated by us but validate anyway)
    if (!/^run-\d+$/.test(run_id)) {
      return NextResponse.json(
        { error: 'Invalid run ID format generated' },
        { status: 500 }
      )
    }

    // Download PDF from Vercel Blob
    let pdfBuffer: ArrayBuffer
    try {
      const blobResponse = await fetch(blob_url)
      if (!blobResponse.ok) {
        throw new Error(`Failed to fetch blob: ${blobResponse.statusText}`)
      }
      pdfBuffer = await blobResponse.arrayBuffer()
    } catch (error) {
      console.error(`Failed to download PDF from blob URL ${blob_url}:`, error)
      return NextResponse.json(
        { error: 'Failed to download uploaded file' },
        { status: 500 }
      )
    }

    // Write PDF to /tmp directory
    const tmpPath = join('/tmp', `${run_id}.pdf`)
    try {
      writeFileSync(tmpPath, Buffer.from(pdfBuffer))
    } catch (error) {
      console.error(`Failed to write PDF to ${tmpPath}:`, error)
      return NextResponse.json(
        { error: 'Failed to save file for processing' },
        { status: 500 }
      )
    }

    // Get project root (go up from innovation-web)
    const projectRoot = join(process.cwd(), '..')

    // Use Python from venv to ensure correct module resolution
    const pythonBin = join(projectRoot, 'venv', 'bin', 'python3')
    const pythonScript = join(projectRoot, 'scripts', 'run_pipeline.py')
    const args = ['--input-file', tmpPath, '--brand', sanitizedCompanyId, '--run-id', run_id]

    console.log(`[${run_id}] Executing pipeline: ${pythonBin} ${pythonScript} ${args.join(' ')}`)

    // Execute Python pipeline in background using execFile (prevents command injection)
    // Using array arguments instead of shell string prevents injection attacks
    execFile(pythonBin, [pythonScript, ...args], { cwd: projectRoot }, (error, stdout, stderr) => {
      if (error) {
        console.error(`[${run_id}] Pipeline execution error:`, error)
      }
      if (stdout) {
        console.log(`[${run_id}] Pipeline stdout:`, stdout)
      }
      if (stderr) {
        console.error(`[${run_id}] Pipeline stderr:`, stderr)
      }
    })

    // Return immediately with run_id (non-blocking)
    return NextResponse.json({
      run_id,
      status: 'running',
    })
  } catch (error) {
    console.error('Unexpected error in /api/run:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}
